[{"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/index.js":"1","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/reportWebVitals.js":"2","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Routing.js":"3","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Authentication/Login.js":"4","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Authentication/Authentication.js":"5","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Home.js":"6","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Firebase/firebase.js":"7","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/Home.js":"8","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/Home.js":"9","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Classroom/Classroom.js":"10","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/Sessions.js":"11","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/Sessions.js":"12","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/AudioBridge.js":"13","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/AudioBridge.js":"14","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/WhiteboardStudent.js":"15","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/Whiteboard.js":"16","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Chatbox/Chatbox.js":"17","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/SlidesBar.js":"18","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Janus/janus.nojquery.js":"19"},{"size":597,"mtime":1661480095130,"results":"20","hashOfConfig":"21"},{"size":362,"mtime":1661480095130,"results":"22","hashOfConfig":"21"},{"size":304,"mtime":1661480095130,"results":"23","hashOfConfig":"21"},{"size":4234,"mtime":1661480095130,"results":"24","hashOfConfig":"21"},{"size":1413,"mtime":1661480095130,"results":"25","hashOfConfig":"21"},{"size":395,"mtime":1661480095130,"results":"26","hashOfConfig":"21"},{"size":606,"mtime":1661480095130,"results":"27","hashOfConfig":"21"},{"size":2782,"mtime":1661480095130,"results":"28","hashOfConfig":"21"},{"size":2658,"mtime":1661480095130,"results":"29","hashOfConfig":"21"},{"size":4196,"mtime":1661480095130,"results":"30","hashOfConfig":"21"},{"size":5506,"mtime":1661480095130,"results":"31","hashOfConfig":"21"},{"size":2689,"mtime":1661480095130,"results":"32","hashOfConfig":"21"},{"size":10379,"mtime":1663435434566,"results":"33","hashOfConfig":"21"},{"size":8449,"mtime":1663432703481,"results":"34","hashOfConfig":"21"},{"size":14822,"mtime":1661480095130,"results":"35","hashOfConfig":"21"},{"size":17676,"mtime":1661480095130,"results":"36","hashOfConfig":"21"},{"size":4210,"mtime":1661480095130,"results":"37","hashOfConfig":"21"},{"size":2763,"mtime":1661480095130,"results":"38","hashOfConfig":"21"},{"size":84525,"mtime":1661480095130,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"1mfbh7r",{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"42"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"42"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"42"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"42"},{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"42"},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"42"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"42"},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"42"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"42"},"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/index.js",[],["88","89"],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/reportWebVitals.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Routing.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Authentication/Login.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Authentication/Authentication.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Home.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Firebase/firebase.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/Home.js",["90"],"import {React, useEffect, useState} from 'react'\nimport db from '../Firebase/firebase.js'\nimport Sessions from './Sessions'\nimport './Home.css'\nimport Classroom from '../Classroom/Classroom.js';\n\n// the props for Sesssions component:\n// props.Name : students name\n// props.StudentId : students id\n// props.SchoolId : School Id\n// props.Year : Students school year\n// props.Lessons: Lesson array (length 3)\n// props.Time : Time the session is booked for\n// ;\n\nfunction Home(props) {\n    const [name, setName] = useState('');\n    const [sessionsInfo, setSessionsInfo] = useState();\n    const userId = props.user;\n    const [launched, setLaunched] = useState();\n    \n    useEffect(() => {\n        let docRef = db.collection(\"Tutors\").doc(`${userId}`);\n        //query the sessions that are on that particular day\n        docRef.get().then((doc) => {\n            if (doc.exists) {\n                // console.log(\"Document data:\", doc.data().Info);\n                const info = doc.data().Info;\n                setSessionsInfo(info.Sessions)\n                setName(info.Name);\n            } else {\n                // doc.data() will be undefined in this case\n                console.log(\"No such document!\");\n            }\n        }).catch((error) => {\n            console.log(\"Error getting document:\", error);\n        });\n\n    },[])\n\n    // console.log(sessionsInfo.StudentId)\n    if(sessionsInfo !== undefined && name !== '' && launched === undefined){\n        return (\n            <div id = \"session-card\">\n                <h1 id=\"tutor-name\">Hi {name}</h1>\n                {sessionsInfo.map( session => (\n                    <Sessions \n                    setLaunched = {setLaunched}\n                    StudentId = {session.StudentId}\n                    Lessons = {session.Lesson}\n                    epoch = {session.epochTime}\n                    SessionId = {session.SessionId}\n                    Time = {session.Time} \n                    //-----------all student details below are obtained from Sessions.js using the StudentId-------------  \n                    // SchoolId = {session.SchoolId}\n                    // Name = {session.StudentName}\n                    // Year = \"Y4\" \n                    \n                    />\n                ))\n                }\n            </div> \n        )\n    }\n    else if(launched !== undefined){\n        return(\n            <Classroom\n            sessionId = {launched.sessionId}\n            lessons = {launched.lessons}\n            username = {name}\n            epoch = {launched.startTime}\n            role = 'tutor'\n        />\n        )\n        \n    }\n    else{\n        return(\n            <div id = \"session-card\">\n                <h1 id=\"tutor-name\">Hi {name}</h1>\n            </div>\n        )\n    }\n    \n}\n\nexport default Home","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/Home.js",["91"],"import {React, useEffect, useState} from 'react'\nimport db from '../Firebase/firebase.js'\nimport Sessions from './Sessions'\nimport './Home.css'\nimport Classroom from '../Classroom/Classroom.js';\n\n// the props for Sesssions component:\n// \n// props.SchoolId : School Id\n// props.Date : Date of the session being booked\n// props.Time : Time the session is booked for\n//props.SessionId : Session Id\n// ;\n\nfunction Home(props) {\n    const [name, setName] = useState('');\n    const [schoolId, setSchoolId] = useState('')\n    const [sessionsInfo, setSessionsInfo] = useState([]);\n    const [launched, setLaunched] = useState();\n\n    const userId = props.user;\n    useEffect(() => {\n        let docRef = db.collection(\"Students\").doc(`${userId}`);\n\n        docRef.get().then((doc) => {\n            if (doc.exists) {\n                // console.log(\"Document data:\", doc.data().Info);\n                const info = doc.data().Info;\n                setSessionsInfo(info.Sessions)\n                setName(info.Name);\n                setSchoolId(info.SchoolId);\n            } else {\n                // doc.data() will be undefined in this case\n                console.log(\"No such document!\");\n            }\n        }).catch((error) => {\n            console.log(\"Error getting document:\", error);\n        });\n\n    },[])\n\n    // console.log(sessionsInfo.StudentId)\n    if(sessionsInfo.length !== 0 && name !== '' && launched === undefined){\n        return (\n            <div id = \"session-card\">\n                <h1 id=\"tutor-name\">Hi {name}</h1>\n                {sessionsInfo.map( session => (\n                    <Sessions\n                    username = {name}\n                    SchoolId = {schoolId}\n                    Date = {session.Date}\n                    Time = {session.Time}\n                    setLaunched = {setLaunched}\n                    SessionId = {session.SessionId} />\n                ))\n                }\n            </div>\n            \n        )\n    }\n\n    else if(sessionsInfo.length === 0 && name !== '' && launched === undefined){\n        return(\n            <div id = \"session-card\">\n                <h1 id = 'tutor-name'>Hi {name}</h1>\n            <h2 id = \"no-session-notification\">No sessions booked for today</h2>\n            </div>\n        )\n    }\n\n    else if(launched !== undefined){\n        return(\n            <Classroom\n            sessionId = {launched.sessionId}\n            username = {name}\n            role = 'student'\n        />\n        )\n    }    \n    else{\n        return(\n            <div id = \"session-card\">\n                <h1 id=\"student-name\">Hi {name}</h1>\n            </div>\n        )\n    }\n    \n}\n\nexport default Home","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Classroom/Classroom.js",["92","93"],"import {React,useEffect, useState} from 'react'\nimport AudioBridge from '../Tutors/AudioBridge'\nimport Whiteboard from '../Whiteboard/Whiteboard';\nimport WhiteboardStudent from '../Whiteboard/WhiteboardStudent';\nimport StudentAudioBridge from '../Students/AudioBridge'\nimport db from '../Firebase/firebase.js'\nimport firebase from 'firebase';\nimport LinearProgress from '@material-ui/core/LinearProgress'\nimport io from 'socket.io-client';\nimport Chatbox from '../Chatbox/Chatbox';\nimport './Classroom.css'\n\nfunction Classroom(props) {\n    const [socket, setSocket] = useState()\n    const [slides, setSlides] = useState([])\n    \n    useEffect(()=>{\n        // setSocket(io('http://localhost:5000'))\n        // setSocket(io('https://bcend.herokuapp.com'))\n        setSocket(io(process.env.REACT_APP_SOCKET_SERVER))\n        if(props.role === 'tutor'){\n            let LessonSlides = []\n            let lessons = props.lessons;\n            lessons.forEach(item => {\n                let docRef = db.collection(\"Lessons\").doc(`${item}`);\n                docRef.get().then((doc) => {\n                    if (doc.exists) {\n                        // console.log(\"Document data:\", doc.data().Slides[0]);\n                        const slidesArr = doc.data().Slides;\n                        // console.log(\"Sessions:\", slidesArr)\n                        LessonSlides.push(slidesArr);\n                        if(LessonSlides.length === props.lessons.length){\n                            setSlides(LessonSlides)\n                        }\n                        // console.log(LessonSlides);\n                    } else {\n                        // doc.data() will be undefined in this case\n                        console.log(\"No such document!\");\n                    }\n                }).catch((error) => {\n                    console.log(\"Error getting document:\", error);\n                });\n            });\n            //initiating array for annotations\n            lessons.forEach(item => {\n                db.collection(\"Sessions\").doc(`${props.sessionId}`).update({\n                    [item]: {}\n                });\n            });\n        }\n        \n    },[])\n\n    const username = props.username;\n    const sessionId = props.sessionId;\n    const role = props.role;\n    \n    if(role === \"tutor\" && socket !== undefined && slides.length === props.lessons.length){\n        return (\n            <div>\n                <AudioBridge \n                username = {username}\n                sessionId = {sessionId}/>\n                <div className = 'interaction-area'>\n                    <div className = 'chatbox'>\n                    <Chatbox\n                        username = {username}\n                        sessionId = {sessionId}\n                        socket = {socket}/>\n                    </div> \n                    <div className = 'whiteboard'>\n                        <Whiteboard\n                        sessionId = {sessionId}\n                        username = {username}\n                        lessonSlides = {slides}\n                        lessonTitles = {props.lessons}\n                        socket = {socket}/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n    else if(role === \"student\" && socket !== undefined){\n        return(\n            <div>\n                <StudentAudioBridge\n                username = {username}\n                sessionId = {sessionId}/>\n                <div className = 'interaction-area'>\n                    <div className = 'chatbox'>\n                        <Chatbox\n                            username = {username}\n                            sessionId = {sessionId}\n                            socket = {socket}/>\n                    </div>\n                    <div className = 'whiteboard'>\n                        <WhiteboardStudent\n                        username = {username}\n                        sessionId = {sessionId}\n                        socket = {socket}/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n    else{\n        return(\n            <div>\n                <LinearProgress />\n            </div>\n        )\n    }\n    \n}\n\nexport default Classroom\n","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/Sessions.js",["94","95","96","97","98"],"import { Button, LinearProgress } from '@material-ui/core';\nimport {React, useState, useEffect} from 'react'\nimport db from '../Firebase/firebase'\nimport './Sessions.css';\n\n// the props will be:\n// props.Name : students name\n// props.StudentId : students id\n// props.SchoolId : School Id\n// props.Year : Students school year\n// props.Lessons: Lesson array (length 3)\n// props.Time : Time the session is booked for\n// ;\n\nfunction Sessions(props) {\n\n    const [studentInfo, setStudentInfo] = useState();\n\n\n    useEffect(() => {\n        let docRef = db.collection('Students').doc(`${props.StudentId}`)\n        docRef.get().then((doc) => {\n            if (doc.exists) {\n                // console.log(\"Document data:\", doc.data().Info);\n                const info = doc.data().Info;\n                setStudentInfo({'Name' : info.Name, 'SchoolId' : info.SchoolId, 'Year' : info.Year})\n            } else {\n                // doc.data() will be undefined in this case\n                console.log(\"No such document!\");\n            }\n        }).catch((error) => {\n            console.log(\"Error getting document:\", error);\n        });\n\n    },[])\n\n    if(studentInfo){\n        return (\n            <div className =  \"session-card-block\">\n            \n                {/* ----------------------------------------This is is the title bar section ----------------------------------------------------------------------------------- */}\n                <div className=\"title-bar\">\n                    <div className=\"card-block__time\">\n                        {props.Time}\n                    </div>\n                    <div className=\"card-block__name\">\n                        <a className=\"student-profile\" href=\"#\">{studentInfo.Name}  {props.StudentId}</a>\n                        {studentInfo.Year}\n                    </div>\n                    <div className=\"card-block__school-name\">\n                        School {studentInfo.SchoolId}\n                    </div>\n                </div>  \n                {/* ---------------------------------------------------Start of card content-------------------------------------------------------------------------------    */}\n                <div className=\"card-block__content\">\n                        <div className=\"card-block__section-row\">\n                                <div className=\"card-block__section-title\">\n                                Now:\n                                </div>\n                                <div className=\"card-block__section-content \">\n                                    <a className=\"\" data-href=\"#\" data-lesson=\"990\" href=\"#\">\n                                    {props.Lessons[0]}\n                                    </a>\n                                    <a className=\"#\" data-href=\"\" data-lesson=\"651\" href=\"#\">\n                                    {props.Lessons[1]}\n                                    </a>\n                                    <a className=\"\" data-href=\"/curriculum/668/lesson_overlay\" data-lesson=\"668\" href=\"#\">\n                                    {props.Lessons[2]}\n                                    </a>\n                                </div>\n                    </div>\n             {/*--------------------------------------------------- The buttons section------------------------------------------------------------------------------------- */}\n                    <div className=\"card-block__button-section\">\n                    <div className=\"card-block__button-wrapper\">\n                        <div id=\"learning-session-1857904-button\" className=\"with-tooltip\" title=\"You are currently not able to launch this session as no student has been assigned\n                            yet or the session is not within 10 minutes of the start time\">\n                        <Button className=\"button button--small button--rewards-board button--hard-disable\" variant=\"contained\" color=\"primary\"\n                        data-session-start=\"1625488200\"\n                        onClick ={\n                            () =>         \n                        {\n                            props.setLaunched({\n                                'sessionId' : props.SessionId, \n                                'lessons' : props.Lessons,\n                                'startTime' : props.epoch\n                        });\n                        }\n                        }\n                            \n                        >Start Session</Button>\n                        {/* <div class=\"meeting-number\" style=\"clear: both;\">\n                        <!-- Meeting number: <br/><strong></strong> -->\n                        </div> */}\n                        </div>\n                    </div>\n                    <div className=\"card-block__button-wrapper\">\n                        <Button className=\"button button--small button--rewards-board\" variant=\"contained\" color=\"primary\" href=\"#\">Add feedback</Button>\n                    </div>\n                    <div className=\"card-block__button-wrapper\">\n                        <Button variant=\"contained\" color=\"primary\" href=\"#\" className=\"button button--small button--rewards-board overlay\" data-href=\"/learning_sessions/1857904/cancel_session\">Cancel</Button>\n                    </div>\n                    </div>\n                </div>\n             \n            </div>\n                )\n    }\n    else{\n        return(\n            <div>\n                <LinearProgress/>\n            </div>\n        )\n    }\n        \n    }\n\n    \n\nexport default Sessions\n","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/Sessions.js",["99"],"import React from 'react'\nimport { Button } from '@material-ui/core';\n\n// the props will be:\n// props.Name : students name\n// props.StudentId : students id\n//props.SessionId : session Id for the call\n// props.SchoolId : School Id\n// props.Year : Students school year\n// props.Time : Time the session is booked for\n// ;\nfunction Sessions(props) {\n    return (\n        <div className =  \"session-card-block\">\n            \n                {/* ----------------------------------------This is is the title bar section ----------------------------------------------------------------------------------- */}\n                <div className=\"title-bar\">\n                    <div className=\"card-block__time\">\n                        {props.Time}\n                    </div>\n                    <div className=\"card-block__name\">\n                        <a className=\"student-profile\" href = \"#\">{props.Name}  {props.StudentId}</a>\n                        {props.Date}\n                    </div>\n                    <div className=\"card-block__school-name\">\n                        School {props.SchoolId}\n                    </div>\n                </div>  \n                {/* ---------------------------------------------------Start of card content-------------------------------------------------------------------------------    */}\n                <div className=\"card-block__content\">\n             {/*--------------------------------------------------- The buttons section------------------------------------------------------------------------------------- */}\n                    <div className=\"card-block__button-section\">\n                    <div className=\"card-block__button-wrapper\">\n                        <div id=\"learning-session-1857904-button\" className=\"with-tooltip\" title=\"You are currently not able to launch this session as no student has been assigned\n                            yet or the session is not within 10 minutes of the start time\">\n                        <Button className=\"button button--small button--rewards-board button--hard-disable\" variant=\"contained\" color=\"primary\"\n                        data-session-start=\"1625488200\"\n                        onClick ={\n                            () =>         \n                        {\n                            props.setLaunched({\n                                'sessionId' : props.SessionId \n                        });\n                        }\n                        }\n                        >Start Session</Button>\n                        </div>\n                    </div>\n                    </div>\n                </div>\n             \n            </div>\n                )\n}\n\n\nexport default Sessions\n","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Tutors/AudioBridge.js",["100","101","102","103"],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Students/AudioBridge.js",["104","105"],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/WhiteboardStudent.js",["106","107","108","109","110","111"],"import React, { useEffect, useRef, useState } from 'react';\nimport db from '../Firebase/firebase'\n//icons for the whiteboard\nimport IconButton from '@material-ui/core/IconButton';\nimport TouchAppIcon from '@material-ui/icons/TouchApp';\nimport KeyboardIcon from '@material-ui/icons/Keyboard';\nimport CreateIcon from '@material-ui/icons/Create';\nimport CropDinIcon from '@material-ui/icons/CropDin';\nimport StopIcon from '@material-ui/icons/Stop';\nimport RadioButtonUncheckedOutlinedIcon from '@material-ui/icons/RadioButtonUncheckedOutlined';\nimport Brightness1Icon from '@material-ui/icons/Brightness1';\nimport TimelineIcon from '@material-ui/icons/Timeline';\n\n\nimport './Whiteboard.css';\n\nconst Whiteboard = (props) => {\n\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [toolName, setToolName] = useState(\"pen\");\n  const [emogi, setEmogi] = useState(\"ðŸ‘†\");\n  const[color,setColor]= useState(\"\");\n\n  const [oldStartPoint, setOldStartPoint] = useState([0,0])\n  const [keyStartPoint, setKeyStartPoint] = useState([0,0])\n\n  const [inputBox, setInputBox] = useState(\"hidden\")\n  const [disableInput, setDisableInput] = useState(\"\")\n\n  const annotations = useRef();\n\n  // const socketRef = useRef(); using Reference from props\n  const socketRef = useRef(props.socket);\n\n  const canvasRef = useRef(null);\n  const contextRef = useRef(null);\n\n  const canvasRef2 = useRef(null);\n  const contextRef2 = useRef(null);\n  \n  const canvasRef3 = useRef(null);\n  const contextRef3 = useRef(null);\n\n\n\n  useEffect(() =>  {\n\n    //canvas define\n    const canvas = canvasRef.current;\n    canvas.width = 800;\n    canvas.height = 600;\n    canvas.style.width = \"800px\";\n    canvas.style.height = \"600px\";\n\n    const context = canvas.getContext(\"2d\");\n    //style the drawing point\n    context.scale(1, 1);//pointer size\n    context.lineCap = \"round\";//ponter shape\n    context.strokeStyle = \"black\";//pointer coloer\n    context.lineWidth = 5;//pointer width\n    contextRef.current = context;\n\n    //canvas 2 define for images\n    const canvas2 = canvasRef2.current;\n    canvas2.width = 800;\n    canvas2.height = 600;\n    canvas2.style.width = \"800px\";\n    canvas2.style.height = \"600px\";\n\n    const context2 = canvas2.getContext(\"2d\");\n    //style the drawing point\n    context2.scale(1, 1);//pointer size\n    contextRef2.current = context2;\n\n    //canvas 3 define for images\n    const canvas3 = canvasRef3.current;\n    canvas3.width = 800;\n    canvas3.height = 600;\n    canvas3.style.width = \"800px\";\n    canvas3.style.height = \"600px\";\n    \n    const context3 = canvas3.getContext(\"2d\");\n    //style the drawing point\n    context3.scale(1, 1);//pointer size\n    contextRef3.current = context3;\n\n    // socketRef.current = io('http://localhost:5000');// initiating this in the classroom and passing via props\n    socketRef.current.emit('join_room', props.sessionId);\n    socketRef.current.on('drawing', onDrawingEvent);\n    socketRef.current.on('text', onTextEvent);\n    socketRef.current.on('image', onImageEvent);\n\n    //realtime listening for annotations and changes\n    db.collection(\"Sessions\").doc(props.sessionId)\n    .onSnapshot((doc) => {\n        console.log(\"Current data: \", doc.data());\n        annotations.current = doc.data();\n    });\n  }, []);\n\n\nuseEffect(() => {\n  if (toolName === \"text\") {\n    \n    current.x = keyStartPoint[0]\n    current.y = keyStartPoint[1]\n  }\n}, [keyStartPoint])\n\n // ----------------------- socket.io connection ----------------------------\n const onDrawingEvent = (data) => {\n  draw(data.x0, data.y0, data.x1, data.y1, data.toolName, data.color);\n}\n\nconst onTextEvent = (data) => {\n  type(data.x0, data.y0, data.text, data.color);\n}\n\nconst onImageEvent = (data) => {\n  contextRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n  let image = document.createElement('img');\n  image.src = data.src;\n  image.onload = function () {\n    contextRef2.current.drawImage(image, 0, 0,800,600)\n  }\n  // contextRef2.current.drawImage(image, 0, 0, 800, 600)\n  // contextRef.current.putImageData(data.annotation,0,0)\n  console.log(annotations.current)\n  if(annotations.current[data.title][data.page] !== undefined){\n    console.log(`We have annotations for this page: ${data.title} ${data.page}`)\n    let image = document.createElement('img');\n    image.src = annotations.current[data.title][data.page];\n    image.onload = function () {\n      contextRef.current.drawImage(image, 0, 0)\n    }\n    \n  }\n  else{\n    contextRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n  }\n  console.log(data.src);\n}\n    \n  const current = {\n    color: 'black',\n  };\n  let drawing = false;\n  let typing = false;\n   // ------------------------------- create the drawing ----------------------------\n\n const draw = (x0, y0, x1, y1, toolName, color, emit) => {\n   console.log(x0,y0,x1,y1)\n  contextRef3.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n  contextRef.current.globalCompositeOperation = \"source-over\";\n  contextRef.current.beginPath();\n  contextRef.current.lineWidth = 1;\n  contextRef.current.strokeStyle = color;\n  if (toolName === \"pen\") {\n    contextRef.current.moveTo(x0, y0);\n    contextRef.current.lineTo(x1, y1);\n    contextRef.current.stroke();\n    contextRef.current.closePath()\n  } \n  else if (toolName === \"eraser\") {\n    contextRef.current.clearRect(x1, y1, 20,20, Math.PI * 2, false);\n  }\n  else if (toolName === \"rect\"){\n      contextRef.current.strokeRect(x0, y0, x1-x0, y1-y0);\n      contextRef.current.closePath();\n  }\n  else if (toolName === \"circle\"){\n    const a = (x1 - x0);\n      const b = (y1 - y0)\n      const length = (Math.sqrt((a * a) + (b * b)))\n      const radius = length/2\n      contextRef.current.arc((x0 + x1)/2, (y0 + y1)/2, radius,0, 2 * Math.PI);\n      contextRef.current.stroke();\n      contextRef.current.closePath()\n  }\n  else if (toolName === \"line\"){\n      contextRef.current.moveTo(x0,y0)\n      contextRef.current.lineTo(x1, y1);\n      contextRef.current.stroke();\n      contextRef.current.closePath();\n  }\n  else if (toolName === \"pointer\"){\n      contextRef3.current.moveTo(x0,y0);\n      contextRef3.current.textAlign = 'left';\n      contextRef3.current.font = \"50px sans-serif\";\n      contextRef3.current.fillText( emogi ,x0, y0);\n      contextRef3.current.fillStyle = \"red\"; \n      contextRef3.current.font = \"10px sans-serif\";\n      contextRef3.current.textAlign = 'left';\n      contextRef3.current.fillText(x1, x0,y0);\n      \n  }\n  if (!emit) { return; }\n\n  socketRef.current.emit('drawing', {\n    x0: x0,\n    y0: y0,\n    x1: x1,\n    y1: y1,\n    toolName,\n    color,\n  });\n};\n// ------------------------------- create the text ----------------------------\nconst type = (x0,y0,text,color,emit) => {\n  console.log(\"we are typing \" + text + \"here:\" + x0 + y0)\n  contextRef.current.font = \"bold 20px sans-serif\"\n  contextRef.current.textBaseline = \"top\"\n  contextRef.current.fillStyle = color;          \n  contextRef.current.fillText(text,x0, y0)\n\n  if (!emit) { return; }\n\n  socketRef.current.emit('text', {\n    x0: x0,\n    y0: y0,\n    text,\n    color,\n  });\n\n}\n\n\n  //when click the eraser button set tool name as a \"eraser\"\n  const getEraser = () => {\n    setToolName(\"eraser\");\n  }\n  const getPen = () => {\n    setToolName(\"pen\");\n  }\n  const getRect = () => {\n    setToolName(\"rect\");\n  }\n  const getCircle = () => {\n    setToolName(\"circle\");\n  }\n  const getText = () => {\n  \tsetToolName(\"text\");\n    setDisableInput(\"\");\n  }\n  const getLine = () => {\n  \tsetToolName(\"line\");\n  }\n  const getPointer = () => {\n  \tsetToolName('pointer');\n  }\n\n  const getColor = (color) => {\n  \tcurrent.color = color;\n  }\n\n\n    // ---------------- mouse movement --------------------------------------\n\n      const onMouseDown = (e) => {\n        if(toolName !== 'text'){\n          drawing = true;\n          if(inputBox !== 'hidden'){\n            setInputBox('hidden');\n          }\n        }\n        else{\n          if(inputBox === 'hidden'){\n            setInputBox('');\n          }\n          setOldStartPoint([keyStartPoint[0], keyStartPoint[1]])\n          setKeyStartPoint([e.nativeEvent.offsetX, e.nativeEvent.offsetY])\n        }\n        current.x = e.nativeEvent.offsetX;\n        current.y = e.nativeEvent.offsetY;\n        console.log(current.x, current.y)\n      };\n  \n      const onMouseMove = (e) => {\n        if (!drawing) { return; }\n        //here we  want to trigger draw for pen and eraser\n        if(toolName === \"pen\" || toolName === \"eraser\"){\n          draw(current.x, current.y, e.nativeEvent.offsetX, e.nativeEvent.offsetY, toolName, current.color, true);\n          current.x = e.nativeEvent.offsetX;\n          current.y = e.nativeEvent.offsetY;\n        }\n        else if(toolName === 'rect' || toolName === 'line' || toolName === 'circle' || toolName === 'pointer'){\n          contextRef3.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n          contextRef3.current.globalCompositeOperation = \"source-over\";\n          contextRef3.current.beginPath();\n          contextRef3.current.strokeStyle = color;\n          if(toolName === 'rect'){\n            contextRef3.current.strokeRect(current.x, current.y, e.nativeEvent.offsetX-current.x, e.nativeEvent.offsetY-current.y);\n          }\n          else if(toolName === 'circle'){\n            const a = (e.nativeEvent.offsetX - current.x);\n            const b = (e.nativeEvent.offsetY - current.y)\n            const length = (Math.sqrt((a * a) + (b * b)))\n            const radius = length/2\n            contextRef3.current.arc((current.x + e.nativeEvent.offsetX)/2, (current.y + e.nativeEvent.offsetY)/2, radius,0, 2 * Math.PI);\n            contextRef3.current.stroke();\n          }\n          else if (toolName === 'line'){\n            contextRef3.current.moveTo(current.x,current.y)\n            contextRef3.current.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n            contextRef3.current.stroke();\n          }\n          else{\n            draw(e.nativeEvent.offsetX, e.nativeEvent.offsetY, props.username.split(' ')[0] , 0, toolName, current.color, true)\n          }\n          \n        }\n      };\n  \n      const onMouseUp = (e) => {\n        console.log(isDrawing, toolName, current.x, current.y)\n        if (!drawing) { return; }\n        drawing = false;\n        //here we want to trigger draw for rect, circle, and line\n        if(toolName !== 'pointer'){\n          draw(current.x, current.y, e.nativeEvent.offsetX, e.nativeEvent.offsetY, toolName, current.color, true);\n        }\n        else{\n          contextRef3.current.clearRect(0,0,canvasRef.current.width, canvasRef.current.height)\n        }\n      };\n\n  // ---------------- keyDown Event --------------------------------------\n  function drawText(event, blur = false){\n      console.log(event.target.value, current.x, current.y)\n    \tconsole.log(blur)\n      console.log(event.keyCode);\n      \n    //when Enter is pressed the text is drawn on canvas\n    //and the input field is set to hidden\n    if(event.key === \"Enter\" || blur === true){\n      if(event.key === \"Enter\"){\n        setKeyStartPoint([keyStartPoint[0], keyStartPoint[1] + 20]);\n        type(current.x, current.y, event.target.value, color, true)\n      }\n      else{\n        type(oldStartPoint[0], oldStartPoint[1],event.target.value,color,true)\n      }\n      \n      event.target.value = \"\"\n    }\n  }\n    \t\t\t\t\n  \n  // ----------- limit the number of events per second -----------------------\n\n  const throttle = (callback, delay) => {\n    let previousCall = new Date().getTime();\n    \n    return function() {\n      const time = new Date().getTime();\n      if ((time - previousCall) >= delay) {\n        previousCall = time;\n        callback.apply(null, arguments);\n      }\n    };\n  };\n\n  return (\n    <div>\n      <div className = \"tool-container\">\n        <IconButton>\n          <TouchAppIcon onClick={() => {getPointer()}} id=\"pointer\" aria-label = 'pointer' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n       \n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('blue')}} id=\"blue\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#4885ed'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('black')}} id=\"black\" aria-label = 'color'  style = {{'font-size': '40px', 'color': '#000000'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('green')}} id=\"green\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#3cba54'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('red')}} id=\"red\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#db3236'}}/>\n        </IconButton>\n\n        <IconButton>\n          <KeyboardIcon onClick={getText} id=\"text\" aria-label = 'text' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <CreateIcon onClick={getPen} id=\"pen\" aria-label = 'pen' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <RadioButtonUncheckedOutlinedIcon  onClick={getCircle} id=\"circle\" aria-label = 'circle' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <CropDinIcon onClick={getRect} id=\"rect\" aria-label = 'rect' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <TimelineIcon onClick={getLine} id=\"line\" aria-label = 'line' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <StopIcon onClick={getEraser} id=\"eraser\" aria-label = 'eraser' style = {{'font-size': '40px'}}/>\n        </IconButton>\n      </div>\n      \n      <div className = \"canvas-container\">\n        <canvas id=\"canvas_3_ID\"\n          ref={canvasRef3}\n          onMouseDown={onMouseDown}\n          onMouseUp={onMouseUp}\n          onMouseMove={(e) => throttle(onMouseMove(e), 10)}\n        />\n        <canvas\n          id = \"overlay\"\n          ref={canvasRef}\n        />\n        <input \n        type = \"text\"\n        id = \"textbox\"\n        onKeyDown ={drawText}\n          style = {{\n          \tposition : \"absolute\",\n            visibility :`${inputBox}`,\n            left:`${keyStartPoint[0]}px`,\n    \t\t\t\ttop:`${keyStartPoint[1]}px`,\n            pointerEvents: `${disableInput}`\n          }}\n        onBlur = {(e) => {\n           drawText(e,true)\n          }}\n        ></input>\n        <canvas id=\"images\"\n          ref={canvasRef2}\n        />\n      </div>\n\n      <div className = \"tool-container\" style={{width:\"800px\",height:\"auto\", display:\"block\" ,position:\"relative\", \n       top:\"600px\", paddingTop:\"10px\",left:\"0px\"\n    }} >\n      </div>\n    </div>\n  );\n}\n\nexport default Whiteboard;\n\n","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/Whiteboard.js",["112","113","114","115","116","117"],"import React, { useEffect, useRef, useState } from 'react';\nimport SlidesBar from './SlidesBar';\nimport db from '../Firebase/firebase';\n//icons for the whiteboard\nimport IconButton from '@material-ui/core/IconButton';\nimport TouchAppIcon from '@material-ui/icons/TouchApp';\nimport KeyboardIcon from '@material-ui/icons/Keyboard';\nimport CreateIcon from '@material-ui/icons/Create';\nimport CropDinIcon from '@material-ui/icons/CropDin';\nimport StopIcon from '@material-ui/icons/Stop';\nimport RadioButtonUncheckedOutlinedIcon from '@material-ui/icons/RadioButtonUncheckedOutlined';\nimport Brightness1Icon from '@material-ui/icons/Brightness1';\nimport TimelineIcon from '@material-ui/icons/Timeline';\nimport TextareaAutosize from 'react-textarea-autosize';\nimport AutowidthInput from \"react-autowidth-input\";\n\nimport './Whiteboard.css';\n\n\nconst Whiteboard = (props) => {\n\n  const [toolName, setToolName] = useState(\"pen\");\n  const emogi = \"ðŸ‘†\";\n  const color = \"\";\n\n  const [oldStartPoint, setOldStartPoint] = useState([0,0])\n  const [keyStartPoint, setKeyStartPoint] = useState([0,0])\n\n  const count = useRef([]);\n  const [selected, setSelected] = useState({active : '', title :''});\n  const [annotations, setAnnotations] = useState();\n\n\n  const [inputBox, setInputBox] = useState(\"hidden\")\n  const [disableInput, setDisableInput] = useState(\"\")\n\n  // const socketRef = useRef(); using Reference from props\n  const socketRef = useRef(props.socket);\n\n  const canvasRef = useRef(null);\n  const contextRef = useRef(null);\n\n  const canvasRef2 = useRef(null);\n  const contextRef2 = useRef(null);\n  \n  const canvasRef3 = useRef(null);\n  const contextRef3 = useRef(null);\n\n  //const { useState, useRef, useEffect } = React;\n\n  useEffect(() => {\n\n    //canvas define\n    const canvas = canvasRef.current;\n    canvas.width = 800;\n    canvas.height = 600;\n    canvas.style.width = \"800px\";\n    canvas.style.height = \"600px\";\n\n    const context = canvas.getContext(\"2d\");\n    //style the drawing point\n    context.scale(1, 1);//pointer size\n    context.lineCap = \"round\";//ponter shape\n    context.strokeStyle = \"black\";//pointer coloer\n    context.lineWidth = 5;//pointer width\n    contextRef.current = context;\n\n    //canvas 2 define for images\n    const canvas2 = canvasRef2.current;\n    canvas2.width = 800;\n    canvas2.height = 600;\n    canvas2.style.width = \"800px\";\n    canvas2.style.height = \"600px\";\n\n    const context2 = canvas2.getContext(\"2d\");\n    //style the drawing point\n    context2.scale(1, 1);//pointer size\n    contextRef2.current = context2;\n\n    //canvas 3 define for images\n    const canvas3 = canvasRef3.current;\n    canvas3.width = 800;\n    canvas3.height = 600;\n    canvas3.style.width = \"800px\";\n    canvas3.style.height = \"600px\";\n    \n    const context3 = canvas3.getContext(\"2d\");\n    //style the drawing point\n    context3.scale(1, 1);//pointer size\n    contextRef3.current = context3;\n\n    // socketRef.current = io('http://localhost:5000');// initiating this in the classroom and passing via props\n    socketRef.current.emit('join_room', props.sessionId);\n    socketRef.current.on('drawing', onDrawingEvent);\n    socketRef.current.on('text', onTextEvent);\n\n    //realtime listening for annotations and changes\n    db.collection(\"Sessions\").doc(props.sessionId)\n    .onSnapshot((doc) => {\n        console.log(\"Current data: \", doc.data());\n        setAnnotations(doc.data());\n    });\n  },[]);\n\n\n\n  useEffect(() => {\n    if (count.current.length !== 0) {\n      //load image and annotations to page\n      //loading the annotations\n      if(annotations[props.lessonTitles[count.current[0]]][count.current[1]]!== undefined){\n        console.log(`We have annotations for this page: ${count.current[0]} ${count.current[1]}`)\n        let image = document.createElement('img');\n        image.src = annotations[props.lessonTitles[count.current[0]]][count.current[1]];\n        image.onload = function () {\n          contextRef.current.drawImage(image, 0, 0)\n        }\n        \n      }\n      else{\n        // contextRef.current.fillStyle = \"rgba(255, 255, 255, 0)\"\n        contextRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n      }\n      //image loading canvas\n      var image = document.getElementById(`${props.lessonTitles[count.current[0]]}${count.current[1]}`);\n      let src = image.src;\n      contextRef2.current.drawImage(image, 0, 0, 800, 600);\n      socketRef.current.emit('image', {\n        src,\n        page : count.current[1],\n        title : props.lessonTitles[count.current[0]],\n      });\n    }\n}, [count.current])\n\nuseEffect(() => {\n  if (toolName === \"text\") {\n    \n    wbData.current.x = keyStartPoint[0]\n    wbData.current.y = keyStartPoint[1]\n  }\n}, [keyStartPoint])\n\n // ----------------------- socket.io connection ----------------------------\n const onDrawingEvent = (data) => {\n  draw(data.x0, data.y0, data.x1, data.y1, data.toolName, data.color);\n}\n\nconst onTextEvent = (data) => {\n  type(data.x0, data.y0, data.text, data.color);\n}\n  \n\n  const wbData = useRef({color : \"black\"});\n  // const current = {\n  //   color: 'black',\n  // };\n  let drawing = false;\n   // ------------------------------- create the drawing ----------------------------\n\n const draw = (x0, y0, x1, y1, toolName, color, emit) => {\n   console.log(x0,y0,x1,y1)\n  contextRef3.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n  contextRef.current.globalCompositeOperation = \"source-over\";\n  contextRef.current.beginPath();\n  contextRef.current.lineWidth = 1;\n  contextRef.current.strokeStyle = color;\n  if (toolName === \"pen\") {\n    contextRef.current.moveTo(x0, y0);\n    contextRef.current.lineTo(x1, y1);\n    contextRef.current.stroke();\n    contextRef.current.closePath()\n  } \n  else if (toolName === \"eraser\") {\n    contextRef.current.clearRect(x1, y1, 20,20, Math.PI * 2, false);\n  }\n  else if (toolName === \"rect\"){\n      contextRef.current.strokeRect(x0, y0, x1-x0, y1-y0);\n      contextRef.current.closePath();\n  }\n  else if (toolName === \"circle\"){\n    const a = (x1 - x0);\n      const b = (y1 - y0)\n      const length = (Math.sqrt((a * a) + (b * b)))\n      const radius = length/2\n      contextRef.current.arc((x0 + x1)/2, (y0 + y1)/2, radius,0, 2 * Math.PI);\n      contextRef.current.stroke();\n      contextRef.current.closePath()\n  }\n  else if (toolName === \"line\"){\n      contextRef.current.moveTo(x0,y0)\n      contextRef.current.lineTo(x1, y1);\n      contextRef.current.stroke();\n      contextRef.current.closePath();\n  }\n  else if (toolName === \"pointer\"){\n      contextRef3.current.moveTo(x0,y0);\n      contextRef3.current.textAlign = 'left';\n      contextRef3.current.font = \"50px sans-serif\";\n      contextRef3.current.fillText( emogi ,x0, y0);\n      contextRef3.current.fillStyle = \"red\"; \n      contextRef3.current.font = \"10px sans-serif\";\n      contextRef3.current.textAlign = 'left';\n      contextRef3.current.fillText(x1, x0,y0);\n      \n  }\n  if (!emit) { return; }\n\n  socketRef.current.emit('drawing', {\n    x0: x0,\n    y0: y0,\n    x1: x1,\n    y1: y1,\n    toolName,\n    color,\n  });\n};\n// ------------------------------- create the text ----------------------------\nconst type = (x0,y0,text,color,emit) => {\n  console.log(\"we are typing \" + text + \"here:\" + x0 + y0)\n  contextRef.current.font = \"25px sans-serif\"\n  contextRef.current.textBaseline = \"top\"\n  contextRef.current.fillStyle = color;          \n  contextRef.current.fillText(text,x0, y0)\n\n  if (!emit) { return; }\n\n  socketRef.current.emit('text', {\n    x0: x0,\n    y0: y0,\n    text,\n    color,\n  });\n\n}\n\n// ---------------- keyDown Event --------------------------------------\nfunction drawText(event, blur = false){\n  console.log(event.target.value, wbData.current.x, wbData.current.y)\n  console.log(blur)\n  console.log(event.keyCode);\n  \n//when Enter is pressed the text is drawn on canvas\n//and the input field is set to hidden\nif(event.key === \"Enter\" || blur === true){\n  if(event.key === \"Enter\"){\n    setKeyStartPoint([keyStartPoint[0], keyStartPoint[1] + 25]);\n    // type(current.x, current.y, event.target.value, current.color, true)\n    type(wbData.current.x, wbData.current.y, event.target.value, wbData.current.color, true)\n  }\n  else{\n    setKeyStartPoint([keyStartPoint[0], keyStartPoint[1] + 25]);\n    type(oldStartPoint[0], oldStartPoint[1],event.target.value,wbData.current.color,true)\n  }\n  \n  event.target.value = \"\"\n}\n}\n\n  //when click the eraser button set tool name as a \"eraser\"\n  const getEraser = () => {\n    setToolName(\"eraser\");\n  }\n  const getPen = () => {\n    setToolName(\"pen\");\n  }\n  const getRect = () => {\n    setToolName(\"rect\");\n  }\n  const getCircle = () => {\n    setToolName(\"circle\");\n  }\n  const getText = () => {\n  \tsetToolName(\"text\");\n    setDisableInput(\"\");\n  }\n  const getLine = () => {\n  \tsetToolName(\"line\");\n  }\n  const getPointer = () => {\n  \tsetToolName(\"pointer\");\n  }\n\n  const getColor = (color) => {\n  \twbData.current.color = color;\n  }\n  \n\n//new annotaitons [[], []]\n  const  getSlide = (lessonTitle , buttonindexID) => {\n\n    //change the styling of the button by updating selected state\n    setSelected({active : buttonindexID, title : lessonTitle})\n    // get the lesson idex\n    let lessonIndex = props.lessonTitles.indexOf(lessonTitle);\n    //ensuring annotation database only updates when page is changed\n    if(count.current.length !== 0 && (count.current[0] !== lessonIndex || count.current[1] !== buttonindexID)){\n      // new_annotations[count] = contextRef.current.getImageData(\n      //   0, 0, canvasRef.current.width, canvasRef.current.height)\n      db.collection(\"Sessions\").doc(`${props.sessionId}`).update({\n        \n      [`${props.lessonTitles[count.current[0]]}.${count.current[1]}`] : canvasRef.current.toDataURL()\n\n      });\n      contextRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n      count.current = [lessonIndex, buttonindexID]\n    }\n\n    else if(count.current.length === 0){\n      contextRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n      count.current = [lessonIndex, buttonindexID]\n      setToolName('Image')\n    }\n\n    else{\n      return;\n    }\n    \n    \n    //emit the event for loading image and annotations on student side....\n  }\n\n\n    // ---------------- mouse movement --------------------------------------\n\n      const onMouseDown = (e) => {\n        if(toolName !== 'text'){\n          drawing = true;\n          if(inputBox !== 'hidden'){\n            setInputBox('hidden');\n          }\n        }\n        else{\n          if(inputBox === 'hidden'){\n            setInputBox('');\n          }\n          setOldStartPoint([keyStartPoint[0], keyStartPoint[1]])\n          setKeyStartPoint([e.nativeEvent.offsetX, e.nativeEvent.offsetY])\n        }\n        wbData.current.x = e.nativeEvent.offsetX;\n        wbData.current.y = e.nativeEvent.offsetY;\n        // console.log(current.x, current.y)\n      };\n  \n      const onMouseMove = (e) => {\n        if (!drawing) { \n          return; \n        }\n        //here we  want to trigger draw for pen and eraser\n        if(toolName === \"pen\" || toolName === \"eraser\"){\n          draw(wbData.current.x, wbData.current.y, e.nativeEvent.offsetX, e.nativeEvent.offsetY, toolName, wbData.current.color, true);\n          wbData.current.x = e.nativeEvent.offsetX;\n          wbData.current.y = e.nativeEvent.offsetY;\n        }\n        else if(toolName === 'rect' || toolName === 'line' || toolName === 'circle' || toolName === 'pointer'){\n          contextRef3.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)\n          contextRef3.current.globalCompositeOperation = \"source-over\";\n          contextRef3.current.beginPath();\n          contextRef3.current.strokeStyle = color;\n          if(toolName === 'rect'){\n            contextRef3.current.strokeRect(wbData.current.x, wbData.current.y, e.nativeEvent.offsetX-wbData.current.x, e.nativeEvent.offsetY-wbData.current.y);\n          }\n          else if(toolName === 'circle'){\n            const a = (e.nativeEvent.offsetX - wbData.current.x);\n            const b = (e.nativeEvent.offsetY - wbData.current.y)\n            const length = (Math.sqrt((a * a) + (b * b)))\n            const radius = length/2\n            contextRef3.current.arc((wbData.current.x + e.nativeEvent.offsetX)/2, (wbData.current.y + e.nativeEvent.offsetY)/2, radius,0, 2 * Math.PI);\n            contextRef3.current.stroke();\n          }\n          else if (toolName === 'line'){\n            contextRef3.current.moveTo(wbData.current.x,wbData.current.y)\n            contextRef3.current.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n            contextRef3.current.stroke();\n          }\n          else{\n            draw(e.nativeEvent.offsetX, e.nativeEvent.offsetY, props.username.split(' ')[0] , 0, toolName, wbData.current.color, true)\n          }\n          \n        }\n      };\n  \n      const onMouseUp = (e) => {\n        console.log(drawing, toolName, wbData.current.x, wbData.current.y)\n        if (!drawing) { return; }\n         //here we want to trigger draw for rect, circle, and line\n          if(toolName !== 'pointer'){\n            draw(wbData.current.x, wbData.current.y, e.nativeEvent.offsetX, e.nativeEvent.offsetY, toolName, wbData.current.color, true);\n          }\n          else{\n            contextRef3.current.clearRect(0,0,canvasRef.current.width, canvasRef.current.height)\n          }\n        drawing = false;\n       \n      };\n\n  //--------------load lessons into slide bar --------------------------------\n  const loadLessons = () =>{\n    return(\n      <div className = \"lesson-container\">\n        {\n          props.lessonSlides.map((user, index) => {\n              return(\n                <SlidesBar\n                  slidesArr = {props.lessonSlides[index]}\n                  lessonTitle = {props.lessonTitles[index]}\n                  selected = {selected}\n                  getSlide = {getSlide}\n                  />\n              )\n          })\n        }\n      </div>\n    )\n  }\n  \n  // ----------- limit the number of events per second -----------------------\n\n  const throttle = (callback, delay) => {\n    let previousCall = new Date().getTime();\n    \n    return function() {\n      const time = new Date().getTime();\n      if ((time - previousCall) >= delay) {\n        previousCall = time;\n        callback.apply(null, arguments);\n      }\n    };\n  };\n\n  return (\n    <div>\n      <div className = \"tool-container\">\n        <IconButton>\n          <TouchAppIcon onClick={() => {getPointer()}} id=\"pointer\" aria-label = 'pointer' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        \n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('blue')}} id=\"blue\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#4885ed'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('black')}} id=\"black\" aria-label = 'color'  style = {{'font-size': '40px', 'color': '#000000'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('green')}} id=\"green\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#3cba54'}}/>\n        </IconButton>\n        <IconButton>\n          <Brightness1Icon onClick={() => {getColor('red')}} id=\"red\" aria-label = 'color' style = {{'font-size': '40px', 'color': '#db3236'}}/>\n        </IconButton>\n\n        <IconButton>\n          <KeyboardIcon onClick={getText} id=\"text\" aria-label = 'text' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <CreateIcon onClick={getPen} id=\"pen\" aria-label = 'pen' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <RadioButtonUncheckedOutlinedIcon  onClick={getCircle} id=\"circle\" aria-label = 'circle' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <CropDinIcon onClick={getRect} id=\"rect\" aria-label = 'rect' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <TimelineIcon onClick={getLine} id=\"line\" aria-label = 'line' color = 'primary' style = {{'font-size': '40px'}}/>\n        </IconButton>\n        <IconButton>\n          <StopIcon onClick={getEraser} id=\"eraser\" aria-label = 'eraser' style = {{'font-size': '40px'}}/>\n        </IconButton>\n      </div>\n\n      <div className = \"canvas-container\">\n        <canvas id=\"canvas_3_ID\"\n          ref={canvasRef3}\n          onMouseDown={onMouseDown}\n          onMouseUp={onMouseUp}\n          onMouseMove={(e) => throttle(onMouseMove(e), 10)}\n        />\n        <canvas\n          id = \"overlay\"\n          ref={canvasRef}\n        />\n        {/* <GrowingInput /> */}\n        \n        <input \n        type = \"text\"\n        id = \"textbox\"\n        onKeyPress= {(e) =>\n          {e.target.style.width = (e.target.value.length + 1) + 'ch'}}\n        onKeyDown ={drawText}\n          style = {{\n          \tposition : \"absolute\",\n            width : \"1\" + 'ch',\n            visibility :`${inputBox}`,\n            left:`${keyStartPoint[0]}px`,\n    \t\t\t\ttop:`${keyStartPoint[1]}px`,\n            pointerEvents: `${disableInput}`\n          }}\n        onBlur = {(e) => {\n           drawText(e,true)\n          }}\n        ></input>\n        <canvas id=\"images\"\n          ref={canvasRef2}\n        />\n      </div>\n\n      <div className = \"tool-container\" style={{width:\"auto\",height:\"auto\" ,position:\"relative\", \n       top:\"600px\", paddingTop:\"10px\"\n    }} >\n      <div className = 'slides-bar'>\n        {loadLessons()}\n      </div>\n      </div>\n      \n    </div>\n  );\n}\n\n\nexport default Whiteboard;\n\n\n","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Chatbox/Chatbox.js",["118"],"import React, { useEffect, useState , useRef } from 'react';\nimport './Chatbox.css';\nimport Button from '@material-ui/core/Button';\nimport db from '../Firebase/firebase'\n\n\n/*\n Flow Chart\n  1-Fill form  msg\n  2-send message how to work\n    1- If Login success send message localstorage\n    ** messgae senderId = reciverId = password or email name one \n    2- same time message sending (one to one)\n    3-firestore\n   3-read message\n   4-delete message \n*/\nconst Chatbox = (props) => {\n    const [messageArray, setMessageArray] = useState([]);\n    const socket = useRef(props.socket);\n\n    useEffect(()=> {\n        if(messageArray.length !== 0){\n            // document.getElementsByClassName('irc-message').lastChild.scrollIntoView({ behavior: \"smooth\" });\n            document.getElementsByClassName('irc-message')[messageArray.length].scrollIntoView({behavior: 'smooth'})\n        }\n        \n    }, [messageArray])\n\n    useEffect(() => {\n        // socket.current = io(\"http://localhost:5000\",{ withCredentials: true, extraHeaders: { \"my-custom-header\": \"abcd\" }  });\n        //we are importing socket from property in classroom\n        //restoring previous message upon refresh by checking if old messages are there\n        let docRef = db.collection(\"Sessions\").doc(props.sessionId);\n                docRef.get().then((doc) => {\n                    //if there is a messages doc created then retrieve the messages history\n                    if (doc.exists) {\n                        if(doc.data().Messages){\n                            setMessageArray(doc.data().Messages)\n                        };\n                    } else {\n                        // doc.data() will be undefined in this case\n                        console.log(\"No such document!\");\n                    }\n                }).catch((error) => {\n                    console.log(\"Error getting document:\", error);\n                });\n    },[]);\n\n\n    const chatlist = messageArray.map((item, index) => {\n            return (\n                <span className='irc-message message-highlight' style = {{'font-size' : '18px'}} key={index}>\n                    <div className = 'irc-time'>{item.time}</div>\n                            {item.sender} : {item.message}\n                </span>\n            );\n      });\n\n    const catchMessage = () => {\n        socket.current.on('chat-message', (res) => {\n             inputMsg(res,false) \n            //  setMessageArray([...messageArray, res]);\n        });\n    }\n\n    function inputMsg(msg, emit){\n        setMessageArray([...messageArray, msg])\n        if(emit){\n            socket.current.emit('chat-message', {\n                'message': msg.message,\n                'sender': props.username,\n                'time': msg.time\n            });\n        }\n        else{\n            return;\n        }\n    }\n\n    function sendMessage(event, type) {\n        let msg = {};\n        if(type === 'key'){\n            if(event.key === 'Enter'){\n                msg.message = event.target.value;\n                event.target.value = null;\n            }\n        }\n        else if(type === 'button'){\n            let txt = document.getElementById('irc-Entrybox')\n            msg.message = txt.value;\n        }\n        else{\n            return;\n        }\n        if(msg.message){\n            msg.sender = props.username.split(' ')[0];\n            // msg.time = \n            inputMsg(msg, true)\n        }\n    \n }\n\n catchMessage();\n\n\n    return (\n        <div id = \"helper-section\">\n            <div id=\"irc-section\">\n                <div id = 'irc-message-container'>\n                    <span className = 'irc-message'>Welcome to your session!</span>\n                        {chatlist}\n                </div>\n                <input \n                        id=\"irc-Entrybox\"\n                        onKeyPress={(e) => {sendMessage(e,'key')}} \n                        placeholder=\"Enter your message here...\"\n                />\n                <Button id = \"irc-sendButton\" variant=\"contained\" style = {{'margin' : '0 auto', 'width': '100px'}} onClick={(e) => {sendMessage(e, 'button')}}>\n                    Send\n                </Button>\n            </div>\n        </div>\n    );\n};\n\n\n\n\n\nexport default Chatbox;","/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Whiteboard/SlidesBar.js",[],"/home/naveen/Documents/CloudLearnX/e-classroom_Beta-0.1.3/src/Component/Janus/janus.nojquery.js",["119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159"],"/*\n\tThe MIT License (MIT)\n\n\tCopyright (c) 2016 Meetecho\n\n\tPermission is hereby granted, free of charge, to any person obtaining\n\ta copy of this software and associated documentation files (the \"Software\"),\n\tto deal in the Software without restriction, including without limitation\n\tthe rights to use, copy, modify, merge, publish, distribute, sublicense,\n\tand/or sell copies of the Software, and to permit persons to whom the\n\tSoftware is furnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included\n\tin all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\tOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n\tTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n\tOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n\tARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\tOTHER DEALINGS IN THE SOFTWARE.\n */\n\n// List of sessions\nimport adapter from 'webrtc-adapter'\n\nJanus.sessions = {};\n\n// Screensharing Chrome Extension ID\nJanus.extensionId = \"hapfgfdkleiggjjpfpenajgdnfckjpaj\";\nJanus.isExtensionEnabled = function() {\n\tif(window.navigator.userAgent.match('Chrome')) {\n\t\tvar chromever = parseInt(window.navigator.userAgent.match(/Chrome\\/(.*) /)[1], 10);\n\t\tvar maxver = 33;\n\t\tif(window.navigator.userAgent.match('Linux'))\n\t\t\tmaxver = 35;\t// \"known\" crash in chrome 34 and 35 on linux\n\t\tif(chromever >= 26 && chromever <= maxver) {\n\t\t\t// Older versions of Chrome don't support this extension-based approach, so lie\n\t\t\treturn true;\n\t\t}\n\t\treturn (document.getElementById('janus-extension-installed') !== null);\n\t} else {\n\t\t// Firefox of others, no need for the extension (but this doesn't mean it will work)\n\t\treturn true;\n\t}\n};\n\nJanus.noop = function() {};\n\n// Initialization\nJanus.init = function(options) {\n\toptions = options || {};\n\toptions.callback = (typeof options.callback == \"function\") ? options.callback : Janus.noop;\n\tif(Janus.initDone === true) {\n\t\t// Already initialized\n\t\toptions.callback();\n\t} else {\n\t\tif(typeof console == \"undefined\" || typeof console.log == \"undefined\")\n\t\t\tconsole = { log: function() {} };\n\t\t// Console logging (all debugging disabled by default)\n\t\tJanus.trace = Janus.noop;\n\t\tJanus.debug = Janus.noop;\n\t\tJanus.vdebug = Janus.noop;\n\t\tJanus.log = Janus.noop;\n\t\tJanus.warn = Janus.noop;\n\t\tJanus.error = Janus.noop;\n\t\tif(options.debug === true || options.debug === \"all\") {\n\t\t\t// Enable all debugging levels\n\t\t\tJanus.trace = console.trace.bind(console);\n\t\t\tJanus.debug = console.debug.bind(console);\n\t\t\tJanus.vdebug = console.debug.bind(console);\n\t\t\tJanus.log = console.log.bind(console);\n\t\t\tJanus.warn = console.warn.bind(console);\n\t\t\tJanus.error = console.error.bind(console);\n\t\t} else if(Array.isArray(options.debug)) {\n\t\t\tfor(var i in options.debug) {\n\t\t\t\tvar d = options.debug[i];\n\t\t\t\tswitch(d) {\n\t\t\t\t\tcase \"trace\":\n\t\t\t\t\t\tJanus.trace = console.trace.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"debug\":\n\t\t\t\t\t\tJanus.debug = console.debug.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"vdebug\":\n\t\t\t\t\t\tJanus.vdebug = console.debug.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"log\":\n\t\t\t\t\t\tJanus.log = console.log.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"warn\":\n\t\t\t\t\t\tJanus.warn = console.warn.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"error\":\n\t\t\t\t\t\tJanus.error = console.error.bind(console);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error(\"Unknown debugging option '\" + d + \"' (supported: 'trace', 'debug', 'vdebug', 'log', warn', 'error')\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tJanus.log(\"Initializing library\");\n\t\t// Helper method to enumerate devices\n\t\tJanus.listDevices = function(callback, config) {\n\t\t\tcallback = (typeof callback == \"function\") ? callback : Janus.noop;\n\t\t\tif (config == null) config = { audio: true, video: true };\n\t\t\tif(navigator.mediaDevices) {\n\t\t\t\tnavigator.mediaDevices.getUserMedia(config)\n\t\t\t\t.then(function(stream) {\n\t\t\t\t\tnavigator.mediaDevices.enumerateDevices().then(function(devices) {\n\t\t\t\t\t\tJanus.debug(devices);\n\t\t\t\t\t\tcallback(devices);\n\t\t\t\t\t\t// Get rid of the now useless stream\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstream.stop();\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar tracks = stream.getTracks();\n\t\t\t\t\t\t\tfor(var i in tracks) {\n\t\t\t\t\t\t\t\tvar mst = tracks[i];\n\t\t\t\t\t\t\t\tif(mst !== null && mst !== undefined)\n\t\t\t\t\t\t\t\t\tmst.stop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(function(err) {\n\t\t\t\t\tJanus.error(err);\n\t\t\t\t\tcallback([]);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tJanus.warn(\"navigator.mediaDevices unavailable\");\n\t\t\t\tcallback([]);\n\t\t\t}\n\t\t}\n\t\t// Helper methods to attach/reattach a stream to a video element (previously part of adapter.js)\n\t\tJanus.attachMediaStream = function(element, stream) {\n\t\t\tif(adapter.browserDetails.browser === 'chrome') {\n\t\t\t\tvar chromever = adapter.browserDetails.version;\n\t\t\t\tif(chromever >= 43) {\n\t\t\t\t\telement.srcObject = stream;\n\t\t\t\t} else if(typeof element.src !== 'undefined') {\n\t\t\t\t\telement.src = URL.createObjectURL(stream);\n\t\t\t\t} else {\n\t\t\t\t\tJanus.error(\"Error attaching stream to element\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.srcObject = stream;\n\t\t\t}\n\t\t};\n\t\tJanus.reattachMediaStream = function(to, from) {\n\t\t\tif(adapter.browserDetails.browser === 'chrome') {\n\t\t\t\tvar chromever = adapter.browserDetails.version;\n\t\t\t\tif(chromever >= 43) {\n\t\t\t\t\tto.srcObject = from.srcObject;\n\t\t\t\t} else if(typeof to.src !== 'undefined') {\n\t\t\t\t\tto.src = from.src;\n\t\t\t\t}\n\t\t\t} else if(adapter.browserDetails.browser === 'safari' || window.navigator.userAgent.match(/iPad/i) || window.navigator.userAgent.match(/iPhone/i)) {\n\t\t\t\tto.src = from.src;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto.srcObject = from.srcObject;\n\t\t\t}\n\t\t};\n\t\t// Prepare a helper method to send AJAX requests in a syntax similar to jQuery (at least for what we care)\n\t\tJanus.ajax = function(params) {\n\t\t\t// Check params\n\t\t\tif(params === null || params === undefined)\n\t\t\t\treturn;\n\t\t\tparams.success = (typeof params.success == \"function\") ? params.success : Janus.noop;\n\t\t\tparams.error = (typeof params.error == \"function\") ? params.error : Janus.noop;\n\t\t\t// Make sure there's an URL\n\t\t\tif(params.url === null || params.url === undefined) {\n\t\t\t\tJanus.error('Missing url', params.url);\n\t\t\t\tparams.error(null, -1, 'Missing url');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Validate async\n\t\t\tparams.async = (params.async === null || params.async === undefined) ? true : (params.async === true);\n\t\t\tJanus.log(params);\n\t\t\t// IE doesn't even know what WebRTC is, so no polyfill needed\n\t\t\tvar XHR = new XMLHttpRequest();\n\t\t\tXHR.open(params.type, params.url, params.async);\n\t\t\tif(params.contentType !== null && params.contentType !== undefined)\n\t\t\t\tXHR.setRequestHeader('Content-type', params.contentType);\n\t\t\tif(params.withCredentials !== null && params.withCredentials !== undefined)\n\t\t\t\tXHR.withCredentials = params.withCredentials;\n\t\t\tif(params.async) {\n\t\t\t\tXHR.onreadystatechange = function () {\n\t\t\t\t\tif(XHR.readyState != 4)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif(XHR.status !== 200) {\n\t\t\t\t\t\t// Got an error?\n\t\t\t\t\t\tparams.error(XHR, XHR.status !== 0 ? XHR.status : 'error', \"\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Got payload\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparams.success(JSON.parse(XHR.responseText));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tparams.error(XHR, XHR.status, 'Could not parse response, error: ' + e + ', text: ' + XHR.responseText);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tXHR.send(params.data);\n\t\t\t\tif(!params.async) {\n\t\t\t\t\tif(XHR.status !== 200) {\n\t\t\t\t\t\t// Got an error?\n\t\t\t\t\t\tparams.error(XHR, XHR.status !== 0 ? XHR.status : 'error', \"\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Got payload\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparams.success(JSON.parse(XHR.responseText));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tparams.error(XHR, XHR.status, 'Could not parse response, error: ' + e + ', text: ' + XHR.responseText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\t// Something broke up\n\t\t\t\tparams.error(XHR, 'error', '');\n\t\t\t};\n\t\t};\n\t\t// Detect tab close: make sure we don't loose existing onbeforeunload handlers\n\t\tvar oldOBF = window.onbeforeunload;\n\t\twindow.onbeforeunload = function() {\n\t\t\tJanus.log(\"Closing window\");\n\t\t\tfor(var s in Janus.sessions) {\n\t\t\t\tif(Janus.sessions[s] !== null && Janus.sessions[s] !== undefined &&\n\t\t\t\t\t\tJanus.sessions[s].destroyOnUnload) {\n\t\t\t\t\tJanus.log(\"Destroying session \" + s);\n\t\t\t\t\tJanus.sessions[s].destroy({asyncRequest: false});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(oldOBF && typeof oldOBF == \"function\")\n\t\t\t\toldOBF();\n\t\t}\n\t\tJanus.initDone = true;\n\t\toptions.callback();\n\t}\n};\n\n// Helper method to check whether WebRTC is supported by this browser\nJanus.isWebrtcSupported = function() {\n\treturn window.RTCPeerConnection !== undefined && window.RTCPeerConnection !== null &&\n\t\tnavigator.getUserMedia !== undefined && navigator.getUserMedia !== null;\n};\n\n// Helper method to create random identifiers (e.g., transaction)\nJanus.randomString = function(len) {\n\tvar charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\tvar randomString = '';\n\tfor (var i = 0; i < len; i++) {\n\t\tvar randomPoz = Math.floor(Math.random() * charSet.length);\n\t\trandomString += charSet.substring(randomPoz,randomPoz+1);\n\t}\n\treturn randomString;\n}\n\n\n// Janus session object\nfunction Janus(gatewayCallbacks) {\n\tif(Janus.initDone === undefined) {\n\t\tgatewayCallbacks.error(\"Library not initialized\");\n\t\treturn {};\n\t}\n\tif(!Janus.isWebrtcSupported()) {\n\t\tgatewayCallbacks.error(\"WebRTC not supported by this browser\");\n\t\treturn {};\n\t}\n\tJanus.log(\"Library initialized: \" + Janus.initDone);\n\tgatewayCallbacks = gatewayCallbacks || {};\n\tgatewayCallbacks.success = (typeof gatewayCallbacks.success == \"function\") ? gatewayCallbacks.success : Janus.noop;\n\tgatewayCallbacks.error = (typeof gatewayCallbacks.error == \"function\") ? gatewayCallbacks.error : Janus.noop;\n\tgatewayCallbacks.destroyed = (typeof gatewayCallbacks.destroyed == \"function\") ? gatewayCallbacks.destroyed : Janus.noop;\n\tif(gatewayCallbacks.server === null || gatewayCallbacks.server === undefined) {\n\t\tgatewayCallbacks.error(\"Invalid gateway url\");\n\t\treturn {};\n\t}\n\tvar websockets = false;\n\tvar ws = null;\n\tvar wsHandlers = {};\n\tvar wsKeepaliveTimeoutId = null;\n\n\tvar servers = null, serversIndex = 0;\n\tvar server = gatewayCallbacks.server;\n\tif(Array.isArray(server)) {\n\t\tJanus.log(\"Multiple servers provided (\" + server.length + \"), will use the first that works\");\n\t\tserver = null;\n\t\tservers = gatewayCallbacks.server;\n\t\tJanus.debug(servers);\n\t} else {\n\t\tif(server.indexOf(\"ws\") === 0) {\n\t\t\twebsockets = true;\n\t\t\tJanus.log(\"Using WebSockets to contact Janus: \" + server);\n\t\t} else {\n\t\t\twebsockets = false;\n\t\t\tJanus.log(\"Using REST API to contact Janus: \" + server);\n\t\t}\n\t}\n\tvar iceServers = gatewayCallbacks.iceServers;\n\tif(iceServers === undefined || iceServers === null)\n\t\ticeServers = [{urls: \"stun:stun.l.google.com:19302\"}];\n\tvar iceTransportPolicy = gatewayCallbacks.iceTransportPolicy;\n\t// Whether IPv6 candidates should be gathered\n\tvar ipv6Support = gatewayCallbacks.ipv6;\n\tif(ipv6Support === undefined || ipv6Support === null)\n\t\tipv6Support = false;\n\t// Whether we should enable the withCredentials flag for XHR requests\n\tvar withCredentials = false;\n\tif(gatewayCallbacks.withCredentials !== undefined && gatewayCallbacks.withCredentials !== null)\n\t\twithCredentials = gatewayCallbacks.withCredentials === true;\n\t// Optional max events\n\tvar maxev = null;\n\tif(gatewayCallbacks.max_poll_events !== undefined && gatewayCallbacks.max_poll_events !== null)\n\t\tmaxev = gatewayCallbacks.max_poll_events;\n\tif(maxev < 1)\n\t\tmaxev = 1;\n\t// Token to use (only if the token based authentication mechanism is enabled)\n\tvar token = null;\n\tif(gatewayCallbacks.token !== undefined && gatewayCallbacks.token !== null)\n\t\ttoken = gatewayCallbacks.token;\n\t// API secret to use (only if the shared API secret is enabled)\n\tvar apisecret = null;\n\tif(gatewayCallbacks.apisecret !== undefined && gatewayCallbacks.apisecret !== null)\n\t\tapisecret = gatewayCallbacks.apisecret;\n\t// Whether we should destroy this session when onbeforeunload is called\n\tthis.destroyOnUnload = true;\n\tif(gatewayCallbacks.destroyOnUnload !== undefined && gatewayCallbacks.destroyOnUnload !== null)\n\t\tthis.destroyOnUnload = (gatewayCallbacks.destroyOnUnload === true);\n\n\tvar connected = false;\n\tvar sessionId = null;\n\tvar pluginHandles = {};\n\tvar that = this;\n\tvar retries = 0;\n\tvar transactions = {};\n\tcreateSession(gatewayCallbacks);\n\n\t// Public methods\n\tthis.getServer = function() { return server; };\n\tthis.isConnected = function() { return connected; };\n\tthis.getSessionId = function() { return sessionId; };\n\tthis.destroy = function(callbacks) { destroySession(callbacks, true); };\n\tthis.attach = function(callbacks) { createHandle(callbacks); };\n\n\tfunction eventHandler() {\n\t\tif(sessionId == null)\n\t\t\treturn;\n\t\tJanus.debug('Long poll...');\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\treturn;\n\t\t}\n\t\tvar longpoll = server + \"/\" + sessionId + \"?rid=\" + new Date().getTime();\n\t\tif(maxev !== undefined && maxev !== null)\n\t\t\tlongpoll = longpoll + \"&maxev=\" + maxev;\n\t\tif(token !== null && token !== undefined)\n\t\t\tlongpoll = longpoll + \"&token=\" + token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\tlongpoll = longpoll + \"&apisecret=\" + apisecret;\n\t\tJanus.ajax({\n\t\t\ttype: 'GET',\n\t\t\turl: longpoll,\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\ttimeout: 60000,\t// FIXME\n\t\t\tsuccess: handleEvent,\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\n\t\t\t\tretries++;\n\t\t\t\tif(retries > 3) {\n\t\t\t\t\t// Did we just lose the gateway? :-(\n\t\t\t\t\tconnected = false;\n\t\t\t\t\tgatewayCallbacks.error(\"Lost connection to the gateway (is it down?)\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\teventHandler();\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private event handler: this will trigger plugin callbacks, if set\n\tfunction handleEvent(json, skipTimeout) {\n\t\tretries = 0;\n\t\tif(!websockets && sessionId !== undefined && sessionId !== null && skipTimeout !== true)\n\t\t\tsetTimeout(eventHandler, 200);\n\t\tif(!websockets && Array.isArray(json)) {\n\t\t\t// We got an array: it means we passed a maxev > 1, iterate on all objects\n\t\t\tfor(var i=0; i<json.length; i++) {\n\t\t\t\thandleEvent(json[i], true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(json[\"janus\"] === \"keepalive\") {\n\t\t\t// Nothing happened\n\t\t\tJanus.vdebug(\"Got a keepalive on session \" + sessionId);\n\t\t\treturn;\n\t\t} else if(json[\"janus\"] === \"ack\") {\n\t\t\t// Just an ack, we can probably ignore\n\t\t\tJanus.debug(\"Got an ack on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar transaction = json[\"transaction\"];\n\t\t\tif(transaction !== null && transaction !== undefined) {\n\t\t\t\tvar reportSuccess = transactions[transaction];\n\t\t\t\tif(reportSuccess !== null && reportSuccess !== undefined) {\n\t\t\t\t\treportSuccess(json);\n\t\t\t\t}\n\t\t\t\tdelete transactions[transaction];\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(json[\"janus\"] === \"success\") {\n\t\t\t// Success!\n\t\t\tJanus.debug(\"Got a success on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar transaction = json[\"transaction\"];\n\t\t\tif(transaction !== null && transaction !== undefined) {\n\t\t\t\tvar reportSuccess = transactions[transaction];\n\t\t\t\tif(reportSuccess !== null && reportSuccess !== undefined) {\n\t\t\t\t\treportSuccess(json);\n\t\t\t\t}\n\t\t\t\tdelete transactions[transaction];\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(json[\"janus\"] === \"webrtcup\") {\n\t\t\t// The PeerConnection with the gateway is up! Notify this\n\t\t\tJanus.debug(\"Got a webrtcup event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\tJanus.debug(\"This handle is not attached to this session\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpluginHandle.webrtcState(true);\n\t\t\treturn;\n\t\t} else if(json[\"janus\"] === \"hangup\") {\n\t\t\t// A plugin asked the core to hangup a PeerConnection on one of our handles\n\t\t\tJanus.debug(\"Got a hangup event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\tJanus.debug(\"This handle is not attached to this session\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpluginHandle.webrtcState(false, json[\"reason\"]);\n\t\t\tpluginHandle.hangup();\n\t\t} else if(json[\"janus\"] === \"detached\") {\n\t\t\t// A plugin asked the core to detach one of our handles\n\t\t\tJanus.debug(\"Got a detached event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\t// Don't warn here because destroyHandle causes this situation.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpluginHandle.detached = true;\n\t\t\tpluginHandle.ondetached();\n\t\t\tpluginHandle.detach();\n\t\t} else if(json[\"janus\"] === \"media\") {\n\t\t\t// Media started/stopped flowing\n\t\t\tJanus.debug(\"Got a media event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\tJanus.debug(\"This handle is not attached to this session\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpluginHandle.mediaState(json[\"type\"], json[\"receiving\"]);\n\t\t} else if(json[\"janus\"] === \"slowlink\") {\n\t\t\tJanus.debug(\"Got a slowlink event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\t// Trouble uplink or downlink\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\tJanus.debug(\"This handle is not attached to this session\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpluginHandle.slowLink(json[\"uplink\"], json[\"nacks\"]);\n\t\t} else if(json[\"janus\"] === \"error\") {\n\t\t\t// Oops, something wrong happened\n\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\tJanus.debug(json);\n\t\t\tvar transaction = json[\"transaction\"];\n\t\t\tif(transaction !== null && transaction !== undefined) {\n\t\t\t\tvar reportSuccess = transactions[transaction];\n\t\t\t\tif(reportSuccess !== null && reportSuccess !== undefined) {\n\t\t\t\t\treportSuccess(json);\n\t\t\t\t}\n\t\t\t\tdelete transactions[transaction];\n\t\t\t}\n\t\t\treturn;\n\t\t} else if(json[\"janus\"] === \"event\") {\n\t\t\tJanus.debug(\"Got a plugin event on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t\tvar sender = json[\"sender\"];\n\t\t\tif(sender === undefined || sender === null) {\n\t\t\t\tJanus.warn(\"Missing sender...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar plugindata = json[\"plugindata\"];\n\t\t\tif(plugindata === undefined || plugindata === null) {\n\t\t\t\tJanus.warn(\"Missing plugindata...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tJanus.debug(\"  -- Event is coming from \" + sender + \" (\" + plugindata[\"plugin\"] + \")\");\n\t\t\tvar data = plugindata[\"data\"];\n\t\t\tJanus.debug(data);\n\t\t\tvar pluginHandle = pluginHandles[sender];\n\t\t\tif(pluginHandle === undefined || pluginHandle === null) {\n\t\t\t\tJanus.warn(\"This handle is not attached to this session\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar jsep = json[\"jsep\"];\n\t\t\tif(jsep !== undefined && jsep !== null) {\n\t\t\t\tJanus.debug(\"Handling SDP as well...\");\n\t\t\t\tJanus.debug(jsep);\n\t\t\t}\n\t\t\tvar callback = pluginHandle.onmessage;\n\t\t\tif(callback !== null && callback !== undefined) {\n\t\t\t\tJanus.debug(\"Notifying application...\");\n\t\t\t\t// Send to callback specified when attaching plugin handle\n\t\t\t\tcallback(data, jsep);\n\t\t\t} else {\n\t\t\t\t// Send to generic callback (?)\n\t\t\t\tJanus.debug(\"No provided notification callback\");\n\t\t\t}\n\t\t} else {\n\t\t\tJanus.warn(\"Unkown message/event  '\" + json[\"janus\"] + \"' on session \" + sessionId);\n\t\t\tJanus.debug(json);\n\t\t}\n\t}\n\n\t// Private helper to send keep-alive messages on WebSockets\n\tfunction keepAlive() {\n\t\tif(server === null || !websockets || !connected)\n\t\t\treturn;\n\t\twsKeepaliveTimeoutId = setTimeout(keepAlive, 30000);\n\t\tvar request = { \"janus\": \"keepalive\", \"session_id\": sessionId, \"transaction\": Janus.randomString(12) };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tws.send(JSON.stringify(request));\n\t}\n\n\t// Private method to create a session\n\tfunction createSession(callbacks) {\n\t\tvar transaction = Janus.randomString(12);\n\t\tvar request = { \"janus\": \"create\", \"transaction\": transaction };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tif(server === null && Array.isArray(servers)) {\n\t\t\t// We still need to find a working server from the list we were given\n\t\t\tserver = servers[serversIndex];\n\t\t\tif(server.indexOf(\"ws\") === 0) {\n\t\t\t\twebsockets = true;\n\t\t\t\tJanus.log(\"Server #\" + (serversIndex+1) + \": trying WebSockets to contact Janus (\" + server + \")\");\n\t\t\t} else {\n\t\t\t\twebsockets = false;\n\t\t\t\tJanus.log(\"Server #\" + (serversIndex+1) + \": trying REST API to contact Janus (\" + server + \")\");\n\t\t\t}\n\t\t}\n\t\tif(websockets) {\n\t\t\tws = new WebSocket(server, 'janus-protocol');\n\t\t\twsHandlers = {\n\t\t\t\t'error': function() {\n\t\t\t\t\tJanus.error(\"Error connecting to the Janus WebSockets server... \" + server);\n\t\t\t\t\tif (Array.isArray(servers)) {\n\t\t\t\t\t\tserversIndex++;\n\t\t\t\t\t\tif (serversIndex == servers.length) {\n\t\t\t\t\t\t\t// We tried all the servers the user gave us and they all failed\n\t\t\t\t\t\t\tcallbacks.error(\"Error connecting to any of the provided Janus servers: Is the gateway down?\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Let's try the next server\n\t\t\t\t\t\tserver = null;\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tcreateSession(callbacks);\n\t\t\t\t\t\t}, 200);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcallbacks.error(\"Error connecting to the Janus WebSockets server: Is the gateway down?\");\n\t\t\t\t},\n\n\t\t\t\t'open': function() {\n\t\t\t\t\t// We need to be notified about the success\n\t\t\t\t\ttransactions[transaction] = function(json) {\n\t\t\t\t\t\tJanus.debug(json);\n\t\t\t\t\t\tif (json[\"janus\"] !== \"success\") {\n\t\t\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\t\t\tcallbacks.error(json[\"error\"].reason);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twsKeepaliveTimeoutId = setTimeout(keepAlive, 30000);\n\t\t\t\t\t\tconnected = true;\n\t\t\t\t\t\tsessionId = json.data[\"id\"];\n\t\t\t\t\t\tJanus.log(\"Created session: \" + sessionId);\n\t\t\t\t\t\tJanus.sessions[sessionId] = that;\n\t\t\t\t\t\tcallbacks.success();\n\t\t\t\t\t};\n\t\t\t\t\tws.send(JSON.stringify(request));\n\t\t\t\t},\n\n\t\t\t\t'message': function(event) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandleEvent(JSON.parse(event.data));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tJanus.error('Error processing event:', e);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t'close': function() {\n\t\t\t\t\tif (server === null || !connected) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconnected = false;\n\t\t\t\t\t// FIXME What if this is called when the page is closed?\n\t\t\t\t\tgatewayCallbacks.error(\"Lost connection to the gateway (is it down?)\");\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor(var eventName in wsHandlers) {\n\t\t\t\tws.addEventListener(eventName, wsHandlers[eventName]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server,\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] !== \"success\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\tcallbacks.error(json[\"error\"].reason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconnected = true;\n\t\t\t\tsessionId = json.data[\"id\"];\n\t\t\t\tJanus.log(\"Created session: \" + sessionId);\n\t\t\t\tJanus.sessions[sessionId] = that;\n\t\t\t\teventHandler();\n\t\t\t\tcallbacks.success();\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t\tif(Array.isArray(servers)) {\n\t\t\t\t\tserversIndex++;\n\t\t\t\t\tif(serversIndex == servers.length) {\n\t\t\t\t\t\t// We tried all the servers the user gave us and they all failed\n\t\t\t\t\t\tcallbacks.error(\"Error connecting to any of the provided Janus servers: Is the gateway down?\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Let's try the next server\n\t\t\t\t\tserver = null;\n\t\t\t\t\tsetTimeout(function() { createSession(callbacks); }, 200);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(errorThrown === \"\")\n\t\t\t\t\tcallbacks.error(textStatus + \": Is the gateway down?\");\n\t\t\t\telse\n\t\t\t\t\tcallbacks.error(textStatus + \": \" + errorThrown);\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private method to destroy a session\n\tfunction destroySession(callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\t// FIXME This method triggers a success even when we fail\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tvar asyncRequest = true;\n\t\tif(callbacks.asyncRequest !== undefined && callbacks.asyncRequest !== null)\n\t\t\tasyncRequest = (callbacks.asyncRequest === true);\n\t\tJanus.log(\"Destroying session \" + sessionId + \" (async=\" + asyncRequest + \")\");\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\tcallbacks.success();\n\t\t\treturn;\n\t\t}\n\t\tif(sessionId === undefined || sessionId === null) {\n\t\t\tJanus.warn(\"No session to destroy\");\n\t\t\tcallbacks.success();\n\t\t\tgatewayCallbacks.destroyed();\n\t\t\treturn;\n\t\t}\n\t\tdelete Janus.sessions[sessionId];\n\t\t// No need to destroy all handles first, Janus will do that itself\n\t\tvar request = { \"janus\": \"destroy\", \"transaction\": Janus.randomString(12) };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tif(websockets) {\n\t\t\trequest[\"session_id\"] = sessionId;\n\n\t\t\tvar unbindWebSocket = function() {\n\t\t\t\tfor(var eventName in wsHandlers) {\n\t\t\t\t\tws.removeEventListener(eventName, wsHandlers[eventName]);\n\t\t\t\t}\n\t\t\t\tws.removeEventListener('message', onUnbindMessage);\n\t\t\t\tws.removeEventListener('error', onUnbindError);\n\t\t\t\tif(wsKeepaliveTimeoutId) {\n\t\t\t\t\tclearTimeout(wsKeepaliveTimeoutId);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar onUnbindMessage = function(event){\n\t\t\t\tvar data = JSON.parse(event.data);\n\t\t\t\tif(data.session_id == request.session_id && data.transaction == request.transaction) {\n\t\t\t\t\tunbindWebSocket();\n\t\t\t\t\tcallbacks.success();\n\t\t\t\t\tgatewayCallbacks.destroyed();\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar onUnbindError = function(event) {\n\t\t\t\tunbindWebSocket();\n\t\t\t\tcallbacks.error(\"Failed to destroy the gateway: Is the gateway down?\");\n\t\t\t\tgatewayCallbacks.destroyed();\n\t\t\t};\n\n\t\t\tws.addEventListener('message', onUnbindMessage);\n\t\t\tws.addEventListener('error', onUnbindError);\n\n\t\t\tws.send(JSON.stringify(request));\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server + \"/\" + sessionId,\n\t\t\tasync: asyncRequest,\t// Sometimes we need false here, or destroying in onbeforeunload won't work\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.log(\"Destroyed session:\");\n\t\t\t\tJanus.debug(json);\n\t\t\t\tsessionId = null;\n\t\t\t\tconnected = false;\n\t\t\t\tif(json[\"janus\"] !== \"success\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t}\n\t\t\t\tcallbacks.success();\n\t\t\t\tgatewayCallbacks.destroyed();\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t\t// Reset everything anyway\n\t\t\t\tsessionId = null;\n\t\t\t\tconnected = false;\n\t\t\t\tcallbacks.success();\n\t\t\t\tgatewayCallbacks.destroyed();\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private method to create a plugin handle\n\tfunction createHandle(callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tcallbacks.consentDialog = (typeof callbacks.consentDialog == \"function\") ? callbacks.consentDialog : Janus.noop;\n\t\tcallbacks.iceState = (typeof callbacks.iceState == \"function\") ? callbacks.iceState : Janus.noop;\n\t\tcallbacks.mediaState = (typeof callbacks.mediaState == \"function\") ? callbacks.mediaState : Janus.noop;\n\t\tcallbacks.webrtcState = (typeof callbacks.webrtcState == \"function\") ? callbacks.webrtcState : Janus.noop;\n\t\tcallbacks.slowLink = (typeof callbacks.slowLink == \"function\") ? callbacks.slowLink : Janus.noop;\n\t\tcallbacks.onmessage = (typeof callbacks.onmessage == \"function\") ? callbacks.onmessage : Janus.noop;\n\t\tcallbacks.onlocalstream = (typeof callbacks.onlocalstream == \"function\") ? callbacks.onlocalstream : Janus.noop;\n\t\tcallbacks.onremotestream = (typeof callbacks.onremotestream == \"function\") ? callbacks.onremotestream : Janus.noop;\n\t\tcallbacks.ondata = (typeof callbacks.ondata == \"function\") ? callbacks.ondata : Janus.noop;\n\t\tcallbacks.ondataopen = (typeof callbacks.ondataopen == \"function\") ? callbacks.ondataopen : Janus.noop;\n\t\tcallbacks.oncleanup = (typeof callbacks.oncleanup == \"function\") ? callbacks.oncleanup : Janus.noop;\n\t\tcallbacks.ondetached = (typeof callbacks.ondetached == \"function\") ? callbacks.ondetached : Janus.noop;\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\tcallbacks.error(\"Is the gateway down? (connected=false)\");\n\t\t\treturn;\n\t\t}\n\t\tvar plugin = callbacks.plugin;\n\t\tif(plugin === undefined || plugin === null) {\n\t\t\tJanus.error(\"Invalid plugin\");\n\t\t\tcallbacks.error(\"Invalid plugin\");\n\t\t\treturn;\n\t\t}\n\t\tvar opaqueId = callbacks.opaqueId;\n\t\tvar transaction = Janus.randomString(12);\n\t\tvar request = { \"janus\": \"attach\", \"plugin\": plugin, \"opaque_id\": opaqueId, \"transaction\": transaction };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\t// If we know the browser supports BUNDLE and/or rtcp-mux, let's advertise those right away\n\t\tif(adapter.browserDetails.browser == \"chrome\" || adapter.browserDetails.browser == \"firefox\") {\n\t\t\trequest[\"force-bundle\"] = true;\n\t\t\trequest[\"force-rtcp-mux\"] = true;\n\t\t}\n\t\tif(websockets) {\n\t\t\ttransactions[transaction] = function(json) {\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] !== \"success\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\tcallbacks.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar handleId = json.data[\"id\"];\n\t\t\t\tJanus.log(\"Created handle: \" + handleId);\n\t\t\t\tvar pluginHandle =\n\t\t\t\t\t{\n\t\t\t\t\t\tsession : that,\n\t\t\t\t\t\tplugin : plugin,\n\t\t\t\t\t\tid : handleId,\n\t\t\t\t\t\tdetached : false,\n\t\t\t\t\t\twebrtcStuff : {\n\t\t\t\t\t\t\tstarted : false,\n\t\t\t\t\t\t\tmyStream : null,\n\t\t\t\t\t\t\tstreamExternal : false,\n\t\t\t\t\t\t\tremoteStream : null,\n\t\t\t\t\t\t\tmySdp : null,\n\t\t\t\t\t\t\tpc : null,\n\t\t\t\t\t\t\tdataChannel : null,\n\t\t\t\t\t\t\tdtmfSender : null,\n\t\t\t\t\t\t\ttrickle : true,\n\t\t\t\t\t\t\ticeDone : false,\n\t\t\t\t\t\t\tsdpSent : false,\n\t\t\t\t\t\t\tvolume : {\n\t\t\t\t\t\t\t\tvalue : null,\n\t\t\t\t\t\t\t\ttimer : null\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbitrate : {\n\t\t\t\t\t\t\t\tvalue : null,\n\t\t\t\t\t\t\t\tbsnow : null,\n\t\t\t\t\t\t\t\tbsbefore : null,\n\t\t\t\t\t\t\t\ttsnow : null,\n\t\t\t\t\t\t\t\ttsbefore : null,\n\t\t\t\t\t\t\t\ttimer : null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tgetId : function() { return handleId; },\n\t\t\t\t\t\tgetPlugin : function() { return plugin; },\n\t\t\t\t\t\tgetVolume : function() { return getVolume(handleId); },\n\t\t\t\t\t\tisAudioMuted : function() { return isMuted(handleId, false); },\n\t\t\t\t\t\tmuteAudio : function() { return mute(handleId, false, true); },\n\t\t\t\t\t\tunmuteAudio : function() { return mute(handleId, false, false); },\n\t\t\t\t\t\tisVideoMuted : function() { return isMuted(handleId, true); },\n\t\t\t\t\t\tmuteVideo : function() { return mute(handleId, true, true); },\n\t\t\t\t\t\tunmuteVideo : function() { return mute(handleId, true, false); },\n\t\t\t\t\t\tgetBitrate : function() { return getBitrate(handleId); },\n\t\t\t\t\t\tsend : function(callbacks) { sendMessage(handleId, callbacks); },\n\t\t\t\t\t\tdata : function(callbacks) { sendData(handleId, callbacks); },\n\t\t\t\t\t\tdtmf : function(callbacks) { sendDtmf(handleId, callbacks); },\n\t\t\t\t\t\tconsentDialog : callbacks.consentDialog,\n\t\t\t\t\t\ticeState : callbacks.iceState,\n\t\t\t\t\t\tmediaState : callbacks.mediaState,\n\t\t\t\t\t\twebrtcState : callbacks.webrtcState,\n\t\t\t\t\t\tslowLink : callbacks.slowLink,\n\t\t\t\t\t\tonmessage : callbacks.onmessage,\n\t\t\t\t\t\tcreateOffer : function(callbacks) { prepareWebrtc(handleId, callbacks); },\n\t\t\t\t\t\tcreateAnswer : function(callbacks) { prepareWebrtc(handleId, callbacks); },\n\t\t\t\t\t\thandleRemoteJsep : function(callbacks) { prepareWebrtcPeer(handleId, callbacks); },\n\t\t\t\t\t\tonlocalstream : callbacks.onlocalstream,\n\t\t\t\t\t\tonremotestream : callbacks.onremotestream,\n\t\t\t\t\t\tondata : callbacks.ondata,\n\t\t\t\t\t\tondataopen : callbacks.ondataopen,\n\t\t\t\t\t\toncleanup : callbacks.oncleanup,\n\t\t\t\t\t\tondetached : callbacks.ondetached,\n\t\t\t\t\t\thangup : function(sendRequest) { cleanupWebrtc(handleId, sendRequest === true); },\n\t\t\t\t\t\tdetach : function(callbacks) { destroyHandle(handleId, callbacks); }\n\t\t\t\t\t}\n\t\t\t\tpluginHandles[handleId] = pluginHandle;\n\t\t\t\tcallbacks.success(pluginHandle);\n\t\t\t};\n\t\t\trequest[\"session_id\"] = sessionId;\n\t\t\tws.send(JSON.stringify(request));\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server + \"/\" + sessionId,\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] !== \"success\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\tcallbacks.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar handleId = json.data[\"id\"];\n\t\t\t\tJanus.log(\"Created handle: \" + handleId);\n\t\t\t\tvar pluginHandle =\n\t\t\t\t\t{\n\t\t\t\t\t\tsession : that,\n\t\t\t\t\t\tplugin : plugin,\n\t\t\t\t\t\tid : handleId,\n\t\t\t\t\t\tdetached : false,\n\t\t\t\t\t\twebrtcStuff : {\n\t\t\t\t\t\t\tstarted : false,\n\t\t\t\t\t\t\tmyStream : null,\n\t\t\t\t\t\t\tstreamExternal : false,\n\t\t\t\t\t\t\tremoteStream : null,\n\t\t\t\t\t\t\tmySdp : null,\n\t\t\t\t\t\t\tpc : null,\n\t\t\t\t\t\t\tdataChannel : null,\n\t\t\t\t\t\t\tdtmfSender : null,\n\t\t\t\t\t\t\ttrickle : true,\n\t\t\t\t\t\t\ticeDone : false,\n\t\t\t\t\t\t\tsdpSent : false,\n\t\t\t\t\t\t\tvolume : {\n\t\t\t\t\t\t\t\tvalue : null,\n\t\t\t\t\t\t\t\ttimer : null\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbitrate : {\n\t\t\t\t\t\t\t\tvalue : null,\n\t\t\t\t\t\t\t\tbsnow : null,\n\t\t\t\t\t\t\t\tbsbefore : null,\n\t\t\t\t\t\t\t\ttsnow : null,\n\t\t\t\t\t\t\t\ttsbefore : null,\n\t\t\t\t\t\t\t\ttimer : null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tgetId : function() { return handleId; },\n\t\t\t\t\t\tgetPlugin : function() { return plugin; },\n\t\t\t\t\t\tgetVolume : function() { return getVolume(handleId); },\n\t\t\t\t\t\tisAudioMuted : function() { return isMuted(handleId, false); },\n\t\t\t\t\t\tmuteAudio : function() { return mute(handleId, false, true); },\n\t\t\t\t\t\tunmuteAudio : function() { return mute(handleId, false, false); },\n\t\t\t\t\t\tisVideoMuted : function() { return isMuted(handleId, true); },\n\t\t\t\t\t\tmuteVideo : function() { return mute(handleId, true, true); },\n\t\t\t\t\t\tunmuteVideo : function() { return mute(handleId, true, false); },\n\t\t\t\t\t\tgetBitrate : function() { return getBitrate(handleId); },\n\t\t\t\t\t\tsend : function(callbacks) { sendMessage(handleId, callbacks); },\n\t\t\t\t\t\tdata : function(callbacks) { sendData(handleId, callbacks); },\n\t\t\t\t\t\tdtmf : function(callbacks) { sendDtmf(handleId, callbacks); },\n\t\t\t\t\t\tconsentDialog : callbacks.consentDialog,\n\t\t\t\t\t\ticeState : callbacks.iceState,\n\t\t\t\t\t\tmediaState : callbacks.mediaState,\n\t\t\t\t\t\twebrtcState : callbacks.webrtcState,\n\t\t\t\t\t\tslowLink : callbacks.slowLink,\n\t\t\t\t\t\tonmessage : callbacks.onmessage,\n\t\t\t\t\t\tcreateOffer : function(callbacks) { prepareWebrtc(handleId, callbacks); },\n\t\t\t\t\t\tcreateAnswer : function(callbacks) { prepareWebrtc(handleId, callbacks); },\n\t\t\t\t\t\thandleRemoteJsep : function(callbacks) { prepareWebrtcPeer(handleId, callbacks); },\n\t\t\t\t\t\tonlocalstream : callbacks.onlocalstream,\n\t\t\t\t\t\tonremotestream : callbacks.onremotestream,\n\t\t\t\t\t\tondata : callbacks.ondata,\n\t\t\t\t\t\tondataopen : callbacks.ondataopen,\n\t\t\t\t\t\toncleanup : callbacks.oncleanup,\n\t\t\t\t\t\tondetached : callbacks.ondetached,\n\t\t\t\t\t\thangup : function(sendRequest) { cleanupWebrtc(handleId, sendRequest === true); },\n\t\t\t\t\t\tdetach : function(callbacks) { destroyHandle(handleId, callbacks); }\n\t\t\t\t\t}\n\t\t\t\tpluginHandles[handleId] = pluginHandle;\n\t\t\t\tcallbacks.success(pluginHandle);\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private method to send a message\n\tfunction sendMessage(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\tcallbacks.error(\"Is the gateway down? (connected=false)\");\n\t\t\treturn;\n\t\t}\n\t\tvar message = callbacks.message;\n\t\tvar jsep = callbacks.jsep;\n\t\tvar transaction = Janus.randomString(12);\n\t\tvar request = { \"janus\": \"message\", \"body\": message, \"transaction\": transaction };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tif(jsep !== null && jsep !== undefined)\n\t\t\trequest.jsep = jsep;\n\t\tJanus.debug(\"Sending message to plugin (handle=\" + handleId + \"):\");\n\t\tJanus.debug(request);\n\t\tif(websockets) {\n\t\t\trequest[\"session_id\"] = sessionId;\n\t\t\trequest[\"handle_id\"] = handleId;\n\t\t\ttransactions[transaction] = function(json) {\n\t\t\t\tJanus.debug(\"Message sent!\");\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] === \"success\") {\n\t\t\t\t\t// We got a success, must have been a synchronous transaction\n\t\t\t\t\tvar plugindata = json[\"plugindata\"];\n\t\t\t\t\tif(plugindata === undefined || plugindata === null) {\n\t\t\t\t\t\tJanus.warn(\"Request succeeded, but missing plugindata...\");\n\t\t\t\t\t\tcallbacks.success();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tJanus.log(\"Synchronous transaction successful (\" + plugindata[\"plugin\"] + \")\");\n\t\t\t\t\tvar data = plugindata[\"data\"];\n\t\t\t\t\tJanus.debug(data);\n\t\t\t\t\tcallbacks.success(data);\n\t\t\t\t\treturn;\n\t\t\t\t} else if(json[\"janus\"] !== \"ack\") {\n\t\t\t\t\t// Not a success and not an ack, must be an error\n\t\t\t\t\tif(json[\"error\"] !== undefined && json[\"error\"] !== null) {\n\t\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\t\tcallbacks.error(json[\"error\"].code + \" \" + json[\"error\"].reason);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJanus.error(\"Unknown error\");\t// FIXME\n\t\t\t\t\t\tcallbacks.error(\"Unknown error\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// If we got here, the plugin decided to handle the request asynchronously\n\t\t\t\tcallbacks.success();\n\t\t\t};\n\t\t\tws.send(JSON.stringify(request));\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server + \"/\" + sessionId + \"/\" + handleId,\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.debug(\"Message sent!\");\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] === \"success\") {\n\t\t\t\t\t// We got a success, must have been a synchronous transaction\n\t\t\t\t\tvar plugindata = json[\"plugindata\"];\n\t\t\t\t\tif(plugindata === undefined || plugindata === null) {\n\t\t\t\t\t\tJanus.warn(\"Request succeeded, but missing plugindata...\");\n\t\t\t\t\t\tcallbacks.success();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tJanus.log(\"Synchronous transaction successful (\" + plugindata[\"plugin\"] + \")\");\n\t\t\t\t\tvar data = plugindata[\"data\"];\n\t\t\t\t\tJanus.debug(data);\n\t\t\t\t\tcallbacks.success(data);\n\t\t\t\t\treturn;\n\t\t\t\t} else if(json[\"janus\"] !== \"ack\") {\n\t\t\t\t\t// Not a success and not an ack, must be an error\n\t\t\t\t\tif(json[\"error\"] !== undefined && json[\"error\"] !== null) {\n\t\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\t\tcallbacks.error(json[\"error\"].code + \" \" + json[\"error\"].reason);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJanus.error(\"Unknown error\");\t// FIXME\n\t\t\t\t\t\tcallbacks.error(\"Unknown error\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// If we got here, the plugin decided to handle the request asynchronously\n\t\t\t\tcallbacks.success();\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t\tcallbacks.error(textStatus + \": \" + errorThrown);\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private method to send a trickle candidate\n\tfunction sendTrickleCandidate(handleId, candidate) {\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\treturn;\n\t\t}\n\t\tvar request = { \"janus\": \"trickle\", \"candidate\": candidate, \"transaction\": Janus.randomString(12) };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tJanus.vdebug(\"Sending trickle candidate (handle=\" + handleId + \"):\");\n\t\tJanus.vdebug(request);\n\t\tif(websockets) {\n\t\t\trequest[\"session_id\"] = sessionId;\n\t\t\trequest[\"handle_id\"] = handleId;\n\t\t\tws.send(JSON.stringify(request));\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server + \"/\" + sessionId + \"/\" + handleId,\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.vdebug(\"Candidate sent!\");\n\t\t\t\tJanus.vdebug(json);\n\t\t\t\tif(json[\"janus\"] !== \"ack\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// Private method to send a data channel message\n\tfunction sendData(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tvar text = callbacks.text;\n\t\tif(text === null || text === undefined) {\n\t\t\tJanus.warn(\"Invalid text\");\n\t\t\tcallbacks.error(\"Invalid text\");\n\t\t\treturn;\n\t\t}\n\t\tJanus.log(\"Sending string on data channel: \" + text);\n\t\tconfig.dataChannel.send(text);\n\t\tcallbacks.success();\n\t}\n\n\t// Private method to send a DTMF tone\n\tfunction sendDtmf(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(config.dtmfSender === null || config.dtmfSender === undefined) {\n\t\t\t// Create the DTMF sender, if possible\n\t\t\tif(config.myStream !== undefined && config.myStream !== null) {\n\t\t\t\tvar tracks = config.myStream.getAudioTracks();\n\t\t\t\tif(tracks !== null && tracks !== undefined && tracks.length > 0) {\n\t\t\t\t\tvar local_audio_track = tracks[0];\n\t\t\t\t\tconfig.dtmfSender = config.pc.createDTMFSender(local_audio_track);\n\t\t\t\t\tJanus.log(\"Created DTMF Sender\");\n\t\t\t\t\tconfig.dtmfSender.ontonechange = function(tone) { Janus.debug(\"Sent DTMF tone: \" + tone.tone); };\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(config.dtmfSender === null || config.dtmfSender === undefined) {\n\t\t\t\tJanus.warn(\"Invalid DTMF configuration\");\n\t\t\t\tcallbacks.error(\"Invalid DTMF configuration\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvar dtmf = callbacks.dtmf;\n\t\tif(dtmf === null || dtmf === undefined) {\n\t\t\tJanus.warn(\"Invalid DTMF parameters\");\n\t\t\tcallbacks.error(\"Invalid DTMF parameters\");\n\t\t\treturn;\n\t\t}\n\t\tvar tones = dtmf.tones;\n\t\tif(tones === null || tones === undefined) {\n\t\t\tJanus.warn(\"Invalid DTMF string\");\n\t\t\tcallbacks.error(\"Invalid DTMF string\");\n\t\t\treturn;\n\t\t}\n\t\tvar duration = dtmf.duration;\n\t\tif(duration === null || duration === undefined)\n\t\t\tduration = 500;\t// We choose 500ms as the default duration for a tone\n\t\tvar gap = dtmf.gap;\n\t\tif(gap === null || gap === undefined)\n\t\t\tgap = 50;\t// We choose 50ms as the default gap between tones\n\t\tJanus.debug(\"Sending DTMF string \" + tones + \" (duration \" + duration + \"ms, gap \" + gap + \"ms)\");\n\t\tconfig.dtmfSender.insertDTMF(tones, duration, gap);\n\t}\n\n\t// Private method to destroy a plugin handle\n\tfunction destroyHandle(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar asyncRequest = true;\n\t\tif(callbacks.asyncRequest !== undefined && callbacks.asyncRequest !== null)\n\t\t\tasyncRequest = (callbacks.asyncRequest === true);\n\t\tJanus.log(\"Destroying handle \" + handleId + \" (sync=\" + asyncRequest + \")\");\n\t\tcleanupWebrtc(handleId);\n\t\tif (pluginHandles[handleId].detached) {\n\t\t\t// Plugin was already detached by Janus, calling detach again will return a handle not found error, so just exit here\n\t\t\tdelete pluginHandles[handleId];\n\t\t\tcallbacks.success();\n\t\t\treturn;\n\t\t}\n\t\tif(!connected) {\n\t\t\tJanus.warn(\"Is the gateway down? (connected=false)\");\n\t\t\tcallbacks.error(\"Is the gateway down? (connected=false)\");\n\t\t\treturn;\n\t\t}\n\t\tvar request = { \"janus\": \"detach\", \"transaction\": Janus.randomString(12) };\n\t\tif(token !== null && token !== undefined)\n\t\t\trequest[\"token\"] = token;\n\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\trequest[\"apisecret\"] = apisecret;\n\t\tif(websockets) {\n\t\t\trequest[\"session_id\"] = sessionId;\n\t\t\trequest[\"handle_id\"] = handleId;\n\t\t\tws.send(JSON.stringify(request));\n\t\t\tdelete pluginHandles[handleId];\n\t\t\tcallbacks.success();\n\t\t\treturn;\n\t\t}\n\t\tJanus.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: server + \"/\" + sessionId + \"/\" + handleId,\n\t\t\tasync: asyncRequest,\t// Sometimes we need false here, or destroying in onbeforeunload won't work\n\t\t\twithCredentials: withCredentials,\n\t\t\tcache: false,\n\t\t\tcontentType: \"application/json\",\n\t\t\tdata: JSON.stringify(request),\n\t\t\tsuccess: function(json) {\n\t\t\t\tJanus.log(\"Destroyed handle:\");\n\t\t\t\tJanus.debug(json);\n\t\t\t\tif(json[\"janus\"] !== \"success\") {\n\t\t\t\t\tJanus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\t// FIXME\n\t\t\t\t}\n\t\t\t\tdelete pluginHandles[handleId];\n\t\t\t\tcallbacks.success();\n\t\t\t},\n\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\tJanus.error(textStatus + \": \" + errorThrown);\t// FIXME\n\t\t\t\t// We cleanup anyway\n\t\t\t\tdelete pluginHandles[handleId];\n\t\t\t\tcallbacks.success();\n\t\t\t},\n\t\t\tdataType: \"json\"\n\t\t});\n\t}\n\n\t// WebRTC stuff\n\tfunction streamsDone(handleId, jsep, media, callbacks, stream) {\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tJanus.debug(\"streamsDone:\", stream);\n\t\tconfig.myStream = stream;\n\t\tvar pc_config = {\"iceServers\": iceServers, \"iceTransportPolicy\": iceTransportPolicy};\n\t\t//~ var pc_constraints = {'mandatory': {'MozDontOfferDataChannel':true}};\n\t\tvar pc_constraints = {\n\t\t\t\"optional\": [{\"DtlsSrtpKeyAgreement\": true}]\n\t\t};\n\t\tif(ipv6Support === true) {\n\t\t\t// FIXME This is only supported in Chrome right now\n\t\t\t// For support in Firefox track this: https://bugzilla.mozilla.org/show_bug.cgi?id=797262\n\t\t\tpc_constraints.optional.push({\"googIPv6\":true});\n\t\t}\n\t\tif(adapter.browserDetails.browser === \"edge\") {\n\t\t\t// This is Edge, enable BUNDLE explicitly\n\t\t\tpc_config.bundlePolicy = \"max-bundle\";\n\t\t}\n\t\tJanus.log(\"Creating PeerConnection\");\n\t\tJanus.debug(pc_constraints);\n\t\tconfig.pc = new RTCPeerConnection(pc_config, pc_constraints);\n\t\tJanus.debug(config.pc);\n\t\tif(config.pc.getStats) {\t// FIXME\n\t\t\tconfig.volume.value = 0;\n\t\t\tconfig.bitrate.value = \"0 kbits/sec\";\n\t\t}\n\t\tJanus.log(\"Preparing local SDP and gathering candidates (trickle=\" + config.trickle + \")\");\n\t\tconfig.pc.oniceconnectionstatechange = function(e) {\n\t\t\tif(config.pc)\n\t\t\t\tpluginHandle.iceState(config.pc.iceConnectionState);\n\t\t};\n\t\tconfig.pc.onicecandidate = function(event) {\n\t\t\tif (event.candidate == null ||\n\t\t\t\t\t(adapter.browserDetails.browser === 'edge' && event.candidate.candidate.indexOf('endOfCandidates') > 0)) {\n\t\t\t\tJanus.log(\"End of candidates.\");\n\t\t\t\tconfig.iceDone = true;\n\t\t\t\tif(config.trickle === true) {\n\t\t\t\t\t// Notify end of candidates\n\t\t\t\t\tsendTrickleCandidate(handleId, {\"completed\": true});\n\t\t\t\t} else {\n\t\t\t\t\t// No trickle, time to send the complete SDP (including all candidates)\n\t\t\t\t\tsendSDP(handleId, callbacks);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// JSON.stringify doesn't work on some WebRTC objects anymore\n\t\t\t\t// See https://code.google.com/p/chromium/issues/detail?id=467366\n\t\t\t\tvar candidate = {\n\t\t\t\t\t\"candidate\": event.candidate.candidate,\n\t\t\t\t\t\"sdpMid\": event.candidate.sdpMid,\n\t\t\t\t\t\"sdpMLineIndex\": event.candidate.sdpMLineIndex\n\t\t\t\t};\n\t\t\t\tif(config.trickle === true) {\n\t\t\t\t\t// Send candidate\n\t\t\t\t\tsendTrickleCandidate(handleId, candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif(stream !== null && stream !== undefined) {\n\t\t\tJanus.log('Adding local stream');\n\t\t\tconfig.pc.addStream(stream);\n\t\t\tpluginHandle.onlocalstream(stream);\n\t\t}\n\t\tconfig.pc.onaddstream = function(remoteStream) {\n\t\t\tJanus.log(\"Handling Remote Stream\");\n\t\t\tJanus.debug(remoteStream);\n\t\t\tconfig.remoteStream = remoteStream;\n\t\t\tpluginHandle.onremotestream(remoteStream.stream);\n\t\t};\n\t\t// Any data channel to create?\n\t\tif(isDataEnabled(media)) {\n\t\t\tJanus.log(\"Creating data channel\");\n\t\t\tvar onDataChannelMessage = function(event) {\n\t\t\t\tJanus.log('Received message on data channel: ' + event.data);\n\t\t\t\tpluginHandle.ondata(event.data);\t// FIXME\n\t\t\t}\n\t\t\tvar onDataChannelStateChange = function() {\n\t\t\t\tvar dcState = config.dataChannel !== null ? config.dataChannel.readyState : \"null\";\n\t\t\t\tJanus.log('State change on data channel: ' + dcState);\n\t\t\t\tif(dcState === 'open') {\n\t\t\t\t\tpluginHandle.ondataopen();\t// FIXME\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar onDataChannelError = function(error) {\n\t\t\t\tJanus.error('Got error on data channel:', error);\n\t\t\t\t// TODO\n\t\t\t}\n\t\t\t// Until we implement the proxying of open requests within the Janus core, we open a channel ourselves whatever the case\n\t\t\tconfig.dataChannel = config.pc.createDataChannel(\"JanusDataChannel\", {ordered:false});\t// FIXME Add options (ordered, maxRetransmits, etc.)\n\t\t\tconfig.dataChannel.onmessage = onDataChannelMessage;\n\t\t\tconfig.dataChannel.onopen = onDataChannelStateChange;\n\t\t\tconfig.dataChannel.onclose = onDataChannelStateChange;\n\t\t\tconfig.dataChannel.onerror = onDataChannelError;\n\t\t}\n\t\t// Create offer/answer now\n\t\tif(jsep === null || jsep === undefined) {\n\t\t\tcreateOffer(handleId, media, callbacks);\n\t\t} else {\n\t\t\tif(adapter.browserDetails.browser === \"edge\") {\n\t\t\t\t// This is Edge, add an a=end-of-candidates at the end\n\t\t\t\tjsep.sdp += \"a=end-of-candidates\\r\\n\";\n\t\t\t}\n\t\t\tconfig.pc.setRemoteDescription(\n\t\t\t\t\tnew RTCSessionDescription(jsep),\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tJanus.log(\"Remote description accepted!\");\n\t\t\t\t\t\tcreateAnswer(handleId, media, callbacks);\n\t\t\t\t\t}, callbacks.error);\n\t\t}\n\t}\n\n\tfunction prepareWebrtc(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : webrtcError;\n\t\tvar jsep = callbacks.jsep;\n\t\tvar media = callbacks.media;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\t// Are we updating a session?\n\t\tif(config.pc !== undefined && config.pc !== null) {\n\t\t\tJanus.log(\"Updating existing media session\");\n\t\t\t// Create offer/answer now\n\t\t\tif(jsep === null || jsep === undefined) {\n\t\t\t\tcreateOffer(handleId, media, callbacks);\n\t\t\t} else {\n\t\t\t\tif(adapter.browserDetails.browser === \"edge\") {\n\t\t\t\t\t// This is Edge, add an a=end-of-candidates at the end\n\t\t\t\t\tjsep.sdp += \"a=end-of-candidates\\r\\n\";\n\t\t\t\t}\n\t\t\t\tconfig.pc.setRemoteDescription(\n\t\t\t\t\t\tnew RTCSessionDescription(jsep),\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\tJanus.log(\"Remote description accepted!\");\n\t\t\t\t\t\t\tcreateAnswer(handleId, media, callbacks);\n\t\t\t\t\t\t}, callbacks.error);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Was a MediaStream object passed, or do we need to take care of that?\n\t\tif(callbacks.stream !== null && callbacks.stream !== undefined) {\n\t\t\tvar stream = callbacks.stream;\n\t\t\tJanus.log(\"MediaStream provided by the application\");\n\t\t\tJanus.debug(stream);\n\t\t\t// Skip the getUserMedia part\n\t\t\tconfig.streamExternal = true;\n\t\t\tstreamsDone(handleId, jsep, media, callbacks, stream);\n\t\t\treturn;\n\t\t}\n\t\tconfig.trickle = isTrickleEnabled(callbacks.trickle);\n\t\tif(isAudioSendEnabled(media) || isVideoSendEnabled(media)) {\n\t\t\tvar constraints = { mandatory: {}, optional: []};\n\t\t\tpluginHandle.consentDialog(true);\n\t\t\tvar audioSupport = isAudioSendEnabled(media);\n\t\t\tif(audioSupport === true && media != undefined && media != null) {\n\t\t\t\tif(typeof media.audio === 'object') {\n\t\t\t\t\taudioSupport = media.audio;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar videoSupport = isVideoSendEnabled(media);\n\t\t\tif(videoSupport === true && media != undefined && media != null) {\n\t\t\t\tif(media.video && media.video != 'screen' && media.video != 'window') {\n\t\t\t\t\tvar width = 0;\n\t\t\t\t\tvar height = 0, maxHeight = 0;\n\t\t\t\t\tif(media.video === 'lowres') {\n\t\t\t\t\t\t// Small resolution, 4:3\n\t\t\t\t\t\theight = 240;\n\t\t\t\t\t\tmaxHeight = 240;\n\t\t\t\t\t\twidth = 320;\n\t\t\t\t\t} else if(media.video === 'lowres-16:9') {\n\t\t\t\t\t\t// Small resolution, 16:9\n\t\t\t\t\t\theight = 180;\n\t\t\t\t\t\tmaxHeight = 180;\n\t\t\t\t\t\twidth = 320;\n\t\t\t\t\t} else if(media.video === 'hires' || media.video === 'hires-16:9' ) {\n\t\t\t\t\t\t// High resolution is only 16:9\n\t\t\t\t\t\theight = 720;\n\t\t\t\t\t\tmaxHeight = 720;\n\t\t\t\t\t\twidth = 1280;\n\t\t\t\t\t\tif(navigator.mozGetUserMedia) {\n\t\t\t\t\t\t\tvar firefoxVer = parseInt(window.navigator.userAgent.match(/Firefox\\/(.*)/)[1], 10);\n\t\t\t\t\t\t\tif(firefoxVer < 38) {\n\t\t\t\t\t\t\t\t// Unless this is and old Firefox, which doesn't support it\n\t\t\t\t\t\t\t\tJanus.warn(media.video + \" unsupported, falling back to stdres (old Firefox)\");\n\t\t\t\t\t\t\t\theight = 480;\n\t\t\t\t\t\t\t\tmaxHeight = 480;\n\t\t\t\t\t\t\t\twidth  = 640;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(media.video === 'stdres') {\n\t\t\t\t\t\t// Normal resolution, 4:3\n\t\t\t\t\t\theight = 480;\n\t\t\t\t\t\tmaxHeight = 480;\n\t\t\t\t\t\twidth  = 640;\n\t\t\t\t\t} else if(media.video === 'stdres-16:9') {\n\t\t\t\t\t\t// Normal resolution, 16:9\n\t\t\t\t\t\theight = 360;\n\t\t\t\t\t\tmaxHeight = 360;\n\t\t\t\t\t\twidth = 640;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJanus.log(\"Default video setting (\" + media.video + \") is stdres 4:3\");\n\t\t\t\t\t\theight = 480;\n\t\t\t\t\t\tmaxHeight = 480;\n\t\t\t\t\t\twidth = 640;\n\t\t\t\t\t}\n\t\t\t\t\tJanus.log(\"Adding media constraint \" + media.video);\n\t\t\t\t\tif(navigator.mozGetUserMedia) {\n\t\t\t\t\t\tvar firefoxVer = parseInt(window.navigator.userAgent.match(/Firefox\\/(.*)/)[1], 10);\n\t\t\t\t\t\tif(firefoxVer < 38) {\n\t\t\t\t\t\t\tvideoSupport = {\n\t\t\t\t\t\t\t\t'require': ['height', 'width'],\n\t\t\t\t\t\t\t\t'height': {'max': maxHeight, 'min': height},\n\t\t\t\t\t\t\t\t'width':  {'max': width,  'min': width}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// http://stackoverflow.com/questions/28282385/webrtc-firefox-constraints/28911694#28911694\n\t\t\t\t\t\t\t// https://github.com/meetecho/janus-gateway/pull/246\n\t\t\t\t\t\t\tvideoSupport = {\n\t\t\t\t\t\t\t\t'height': {'ideal': height},\n\t\t\t\t\t\t\t\t'width':  {'ideal': width}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvideoSupport = {\n\t\t\t\t\t\t    'mandatory': {\n\t\t\t\t\t\t        'maxHeight': maxHeight,\n\t\t\t\t\t\t        'minHeight': height,\n\t\t\t\t\t\t        'maxWidth':  width,\n\t\t\t\t\t\t        'minWidth':  width\n\t\t\t\t\t\t    },\n\t\t\t\t\t\t    'optional': []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif(typeof media.video === 'object') {\n\t\t\t\t\t\tvideoSupport = media.video;\n\t\t\t\t\t}\n\t\t\t\t\tJanus.debug(videoSupport);\n\t\t\t\t} else if(media.video === 'screen' || media.video === 'window') {\n\t\t\t\t\tif (!media.screenshareFrameRate) {\n\t\t\t\t\t\tmedia.screenshareFrameRate = 3;\n\t\t\t\t\t}\n\t\t\t\t\t// Not a webcam, but screen capture\n\t\t\t\t\tif(window.location.protocol !== 'https:') {\n\t\t\t\t\t\t// Screen sharing mandates HTTPS\n\t\t\t\t\t\tJanus.warn(\"Screen sharing only works on HTTPS, try the https:// version of this page\");\n\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\tcallbacks.error(\"Screen sharing only works on HTTPS, try the https:// version of this page\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// We're going to try and use the extension for Chrome 34+, the old approach\n\t\t\t\t\t// for older versions of Chrome, or the experimental support in Firefox 33+\n\t\t\t\t\tvar cache = {};\n\t\t\t\t\tfunction callbackUserMedia (error, stream) {\n\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\tif(error) {\n\t\t\t\t\t\t\tcallbacks.error({code: error.code, name: error.name, message: error.message});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamsDone(handleId, jsep, media, callbacks, stream);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tfunction getScreenMedia(constraints, gsmCallback, useAudio) {\n\t\t\t\t\t\tJanus.log(\"Adding media constraint (screen capture)\");\n\t\t\t\t\t\tJanus.debug(constraints);\n\t\t\t\t\t\tnavigator.mediaDevices.getUserMedia(constraints)\n\t\t\t\t\t\t\t.then(function(stream) { \n\t\t\t\t\t\t\t\tif(useAudio){\n\t\t\t\t\t\t\t\t\tnavigator.mediaDevices.getUserMedia({ audio: true, video: false })\n\t\t\t\t\t\t\t\t\t.then(function (audioStream) {\n\t\t\t\t\t\t\t\t\t\tstream.addTrack(audioStream.getAudioTracks()[0]);\n\t\t\t\t\t\t\t\t\t\tgsmCallback(null, stream);\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgsmCallback(null, stream);\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t })\n\t\t\t\t\t\t\t.catch(function(error) { pluginHandle.consentDialog(false); gsmCallback(error); });\n\t\t\t\t\t};\n\t\t\t\t\tif(adapter.browserDetails.browser === 'chrome') {\n\t\t\t\t\t\tvar chromever = adapter.browserDetails.version;\n\t\t\t\t\t\tvar maxver = 33;\n\t\t\t\t\t\tif(window.navigator.userAgent.match('Linux'))\n\t\t\t\t\t\t\tmaxver = 35;\t// \"known\" crash in chrome 34 and 35 on linux\n\t\t\t\t\t\tif(chromever >= 26 && chromever <= maxver) {\n\t\t\t\t\t\t\t// Chrome 26->33 requires some awkward chrome://flags manipulation\n\t\t\t\t\t\t\tconstraints = {\n\t\t\t\t\t\t\t\tvideo: {\n\t\t\t\t\t\t\t\t\tmandatory: {\n\t\t\t\t\t\t\t\t\t\tgoogLeakyBucket: true,\n\t\t\t\t\t\t\t\t\t\tmaxWidth: window.screen.width,\n\t\t\t\t\t\t\t\t\t\tmaxHeight: window.screen.height,\n\t\t\t\t\t\t\t\t\t\tminFrameRate: media.screenshareFrameRate,\n\t\t\t\t\t\t\t\t\t\tmaxFrameRate: media.screenshareFrameRate,\n\t\t\t\t\t\t\t\t\t\tchromeMediaSource: 'screen'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taudio: isAudioSendEnabled(media)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgetScreenMedia(constraints, callbackUserMedia);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Chrome 34+ requires an extension\n\t\t\t\t\t\t\tvar pending = window.setTimeout(\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\terror = new Error('NavigatorUserMediaError');\n\t\t\t\t\t\t\t\t\terror.name = 'The required Chrome extension is not installed: click <a href=\"#\">here</a> to install it. (NOTE: this will need you to refresh the page)';\n\t\t\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\t\t\treturn callbacks.error(error);\n\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\tcache[pending] = [callbackUserMedia, null];\n\t\t\t\t\t\t\twindow.postMessage({ type: 'janusGetScreen', id: pending }, '*');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (window.navigator.userAgent.match('Firefox')) {\n\t\t\t\t\t\tvar ffver = parseInt(window.navigator.userAgent.match(/Firefox\\/(.*)/)[1], 10);\n\t\t\t\t\t\tif(ffver >= 33) {\n\t\t\t\t\t\t\t// Firefox 33+ has experimental support for screen sharing\n\t\t\t\t\t\t\tconstraints = {\n\t\t\t\t\t\t\t\tvideo: {\n\t\t\t\t\t\t\t\t\tmozMediaSource: media.video,\n\t\t\t\t\t\t\t\t\tmediaSource: media.video\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\taudio: isAudioSendEnabled(media)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgetScreenMedia(constraints, function (err, stream) {\n\t\t\t\t\t\t\t\tcallbackUserMedia(err, stream);\n\t\t\t\t\t\t\t\t// Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1045810\n\t\t\t\t\t\t\t\tif (!err) {\n\t\t\t\t\t\t\t\t\tvar lastTime = stream.currentTime;\n\t\t\t\t\t\t\t\t\tvar polly = window.setInterval(function () {\n\t\t\t\t\t\t\t\t\t\tif(!stream)\n\t\t\t\t\t\t\t\t\t\t\twindow.clearInterval(polly);\n\t\t\t\t\t\t\t\t\t\tif(stream.currentTime == lastTime) {\n\t\t\t\t\t\t\t\t\t\t\twindow.clearInterval(polly);\n\t\t\t\t\t\t\t\t\t\t\tif(stream.onended) {\n\t\t\t\t\t\t\t\t\t\t\t\tstream.onended();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastTime = stream.currentTime;\n\t\t\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar error = new Error('NavigatorUserMediaError');\n\t\t\t\t\t\t\terror.name = 'Your version of Firefox does not support screen sharing, please install Firefox 33 (or more recent versions)';\n\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\tcallbacks.error(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for events from the Chrome Extension\n\t\t\t\t\twindow.addEventListener('message', function (event) {\n\t\t\t\t\t\tif(event.origin != window.location.origin)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tif(event.data.type == 'janusGotScreen' && cache[event.data.id]) {\n\t\t\t\t\t\t\tvar data = cache[event.data.id];\n\t\t\t\t\t\t\tvar callback = data[0];\n\t\t\t\t\t\t\tdelete cache[event.data.id];\n\n\t\t\t\t\t\t\tif (event.data.sourceId === '') {\n\t\t\t\t\t\t\t\t// user canceled\n\t\t\t\t\t\t\t\tvar error = new Error('NavigatorUserMediaError');\n\t\t\t\t\t\t\t\terror.name = 'You cancelled the request for permission, giving up...';\n\t\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\t\tcallbacks.error(error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconstraints = {\n\t\t\t\t\t\t\t\t\taudio: false,\n\t\t\t\t\t\t\t\t\tvideo: {\n\t\t\t\t\t\t\t\t\t\tmandatory: {\n\t\t\t\t\t\t\t\t\t\t\tchromeMediaSource: 'desktop',\n\t\t\t\t\t\t\t\t\t\t\tmaxWidth: window.screen.width,\n\t\t\t\t\t\t\t\t\t\t\tmaxHeight: window.screen.height,\n\t\t\t\t\t\t\t\t\t\t\tminFrameRate: media.screenshareFrameRate,\n\t\t\t\t\t\t\t\t\t\t\tmaxFrameRate: media.screenshareFrameRate,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\toptional: [\n\t\t\t\t\t\t\t\t\t\t\t{googLeakyBucket: true},\n\t\t\t\t\t\t\t\t\t\t\t{googTemporalLayeredScreencast: true}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tconstraints.video.mandatory.chromeMediaSourceId = event.data.sourceId;\n\t\t\t\t\t\t\t\tgetScreenMedia(constraints, callback, isAudioSendEnabled(media));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (event.data.type == 'janusGetScreenPending') {\n\t\t\t\t\t\t\twindow.clearTimeout(event.data.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we got here, we're not screensharing\n\t\t\tif(media === null || media === undefined || media.video !== 'screen') {\n\t\t\t\t// Check whether all media sources are actually available or not\n\t\t\t\tnavigator.mediaDevices.enumerateDevices().then(function(devices) {\n\t\t\t\t\tvar audioExist = devices.some(function(device) {\n\t\t\t\t\t\treturn device.kind === 'audioinput';\n\t\t\t\t\t}),\n\t\t\t\t\tvideoExist = devices.some(function(device) {\n\t\t\t\t\t\treturn device.kind === 'videoinput';\n\t\t\t\t\t});\n\n\t\t\t\t\t// Check whether a missing device is really a problem\n\t\t\t\t\tvar audioSend = isAudioSendEnabled(media);\n\t\t\t\t\tvar videoSend = isVideoSendEnabled(media);\n\t\t\t\t\tvar needAudioDevice = isAudioSendRequired(media);\n\t\t\t\t\tvar needVideoDevice = isVideoSendRequired(media);\n\t\t\t\t\tif(audioSend || videoSend || needAudioDevice || needVideoDevice) {\n\t\t\t\t\t\t// We need to send either audio or video\n\t\t\t\t\t\tvar haveAudioDevice = audioSend ? audioExist : false;\n\t\t\t\t\t\tvar haveVideoDevice = videoSend ? videoExist : false;\n\t\t\t\t\t\tif(!haveAudioDevice && !haveVideoDevice) {\n\t\t\t\t\t\t\t// FIXME Should we really give up, or just assume recvonly for both?\n\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\tcallbacks.error('No capture device found');\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else if(!haveAudioDevice && needAudioDevice) {\n\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\tcallbacks.error('Audio capture is required, but no capture device found');\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else if(!haveVideoDevice && needVideoDevice) {\n\t\t\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\t\t\tcallbacks.error('Video capture is required, but no capture device found');\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigator.mediaDevices.getUserMedia({\n\t\t\t\t\t\taudio: audioExist ? audioSupport : false,\n\t\t\t\t\t\tvideo: videoExist ? videoSupport : false\n\t\t\t\t\t})\n\t\t\t\t\t.then(function(stream) { pluginHandle.consentDialog(false); streamsDone(handleId, jsep, media, callbacks, stream); })\n\t\t\t\t\t.catch(function(error) { pluginHandle.consentDialog(false); callbacks.error({code: error.code, name: error.name, message: error.message}); });\n\t\t\t\t})\n\t\t\t\t.catch(function(error) {\n\t\t\t\t\tpluginHandle.consentDialog(false);\n\t\t\t\t\tcallbacks.error('enumerateDevices error', error);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// No need to do a getUserMedia, create offer/answer right away\n\t\t\tstreamsDone(handleId, jsep, media, callbacks);\n\t\t}\n\t}\n\n\tfunction prepareWebrtcPeer(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : webrtcError;\n\t\tvar jsep = callbacks.jsep;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(jsep !== undefined && jsep !== null) {\n\t\t\tif(config.pc === null) {\n\t\t\t\tJanus.warn(\"Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep\");\n\t\t\t\tcallbacks.error(\"No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(adapter.browserDetails.browser === \"edge\") {\n\t\t\t\t// This is Edge, add an a=end-of-candidates at the end\n\t\t\t\tjsep.sdp += \"a=end-of-candidates\\r\\n\";\n\t\t\t}\n\t\t\tconfig.pc.setRemoteDescription(\n\t\t\t\t\tnew RTCSessionDescription(jsep),\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\tJanus.log(\"Remote description accepted!\");\n\t\t\t\t\t\tcallbacks.success();\n\t\t\t\t\t}, callbacks.error);\n\t\t} else {\n\t\t\tcallbacks.error(\"Invalid JSEP\");\n\t\t}\n\t}\n\n\tfunction createOffer(handleId, media, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tJanus.log(\"Creating offer (iceDone=\" + config.iceDone + \")\");\n\t\t// https://code.google.com/p/webrtc/issues/detail?id=3508\n\t\tvar mediaConstraints = null;\n\t\tif(adapter.browserDetails.browser == \"firefox\" || adapter.browserDetails.browser == \"edge\") {\n\t\t\tmediaConstraints = {\n\t\t\t\t'offerToReceiveAudio':isAudioRecvEnabled(media),\n\t\t\t\t'offerToReceiveVideo':isVideoRecvEnabled(media)\n\t\t\t};\n\t\t} else {\n\t\t\tmediaConstraints = {\n\t\t\t\t'mandatory': {\n\t\t\t\t\t'OfferToReceiveAudio':isAudioRecvEnabled(media),\n\t\t\t\t\t'OfferToReceiveVideo':isVideoRecvEnabled(media)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tJanus.debug(mediaConstraints);\n\t\tconfig.pc.createOffer(\n\t\t\tfunction(offer) {\n\t\t\t\tJanus.debug(offer);\n\t\t\t\tif(config.mySdp === null || config.mySdp === undefined) {\n\t\t\t\t\tJanus.log(\"Setting local description\");\n\t\t\t\t\tconfig.mySdp = offer.sdp;\n\t\t\t\t\tconfig.pc.setLocalDescription(offer);\n\t\t\t\t}\n\t\t\t\tif(!config.iceDone && !config.trickle) {\n\t\t\t\t\t// Don't do anything until we have all candidates\n\t\t\t\t\tJanus.log(\"Waiting for all candidates...\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(config.sdpSent) {\n\t\t\t\t\tJanus.log(\"Offer already sent, not sending it again\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tJanus.log(\"Offer ready\");\n\t\t\t\tJanus.debug(callbacks);\n\t\t\t\tconfig.sdpSent = true;\n\t\t\t\t// JSON.stringify doesn't work on some WebRTC objects anymore\n\t\t\t\t// See https://code.google.com/p/chromium/issues/detail?id=467366\n\t\t\t\tvar jsep = {\n\t\t\t\t\t\"type\": offer.type,\n\t\t\t\t\t\"sdp\": offer.sdp\n\t\t\t\t};\n\t\t\t\tcallbacks.success(jsep);\n\t\t\t}, callbacks.error, mediaConstraints);\n\t}\n\n\tfunction createAnswer(handleId, media, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\tcallbacks.error(\"Invalid handle\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tJanus.log(\"Creating answer (iceDone=\" + config.iceDone + \")\");\n\t\tvar mediaConstraints = null;\n\t\tif(adapter.browserDetails.browser == \"firefox\" || adapter.browserDetails.browser == \"edge\") {\n\t\t\tmediaConstraints = {\n\t\t\t\t'offerToReceiveAudio':isAudioRecvEnabled(media),\n\t\t\t\t'offerToReceiveVideo':isVideoRecvEnabled(media)\n\t\t\t};\n\t\t} else {\n\t\t\tmediaConstraints = {\n\t\t\t\t'mandatory': {\n\t\t\t\t\t'OfferToReceiveAudio':isAudioRecvEnabled(media),\n\t\t\t\t\t'OfferToReceiveVideo':isVideoRecvEnabled(media)\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tJanus.debug(mediaConstraints);\n\t\tconfig.pc.createAnswer(\n\t\t\tfunction(answer) {\n\t\t\t\tJanus.debug(answer);\n\t\t\t\tif(config.mySdp === null || config.mySdp === undefined) {\n\t\t\t\t\tJanus.log(\"Setting local description\");\n\t\t\t\t\tconfig.mySdp = answer.sdp;\n\t\t\t\t\tconfig.pc.setLocalDescription(answer);\n\t\t\t\t}\n\t\t\t\tif(!config.iceDone && !config.trickle) {\n\t\t\t\t\t// Don't do anything until we have all candidates\n\t\t\t\t\tJanus.log(\"Waiting for all candidates...\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(config.sdpSent) {\t// FIXME badly\n\t\t\t\t\tJanus.log(\"Answer already sent, not sending it again\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconfig.sdpSent = true;\n\t\t\t\t// JSON.stringify doesn't work on some WebRTC objects anymore\n\t\t\t\t// See https://code.google.com/p/chromium/issues/detail?id=467366\n\t\t\t\tvar jsep = {\n\t\t\t\t\t\"type\": answer.type,\n\t\t\t\t\t\"sdp\": answer.sdp\n\t\t\t\t};\n\t\t\t\tcallbacks.success(jsep);\n\t\t\t}, callbacks.error, mediaConstraints);\n\t}\n\n\tfunction sendSDP(handleId, callbacks) {\n\t\tcallbacks = callbacks || {};\n\t\tcallbacks.success = (typeof callbacks.success == \"function\") ? callbacks.success : Janus.noop;\n\t\tcallbacks.error = (typeof callbacks.error == \"function\") ? callbacks.error : Janus.noop;\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle, not sending anything\");\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tJanus.log(\"Sending offer/answer SDP...\");\n\t\tif(config.mySdp === null || config.mySdp === undefined) {\n\t\t\tJanus.warn(\"Local SDP instance is invalid, not sending anything...\");\n\t\t\treturn;\n\t\t}\n\t\tconfig.mySdp = {\n\t\t\t\"type\": config.pc.localDescription.type,\n\t\t\t\"sdp\": config.pc.localDescription.sdp\n\t\t};\n\t\tif(config.sdpSent) {\n\t\t\tJanus.log(\"Offer/Answer SDP already sent, not sending it again\");\n\t\t\treturn;\n\t\t}\n\t\tif(config.trickle === false)\n\t\t\tconfig.mySdp[\"trickle\"] = false;\n\t\tJanus.debug(callbacks);\n\t\tconfig.sdpSent = true;\n\t\tcallbacks.success(config.mySdp);\n\t}\n\n\tfunction getVolume(handleId) {\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\treturn 0;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\t// Start getting the volume, if getStats is supported\n\t\tif(config.pc.getStats && adapter.browserDetails.browser == \"chrome\") {\t// FIXME\n\t\t\tif(config.remoteStream === null || config.remoteStream === undefined) {\n\t\t\t\tJanus.warn(\"Remote stream unavailable\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// http://webrtc.googlecode.com/svn/trunk/samples/js/demos/html/constraints-and-stats.html\n\t\t\tif(config.volume.timer === null || config.volume.timer === undefined) {\n\t\t\t\tJanus.log(\"Starting volume monitor\");\n\t\t\t\tconfig.volume.timer = setInterval(function() {\n\t\t\t\t\tconfig.pc.getStats(function(stats) {\n\t\t\t\t\t\tvar results = stats.result();\n\t\t\t\t\t\tfor(var i=0; i<results.length; i++) {\n\t\t\t\t\t\t\tvar res = results[i];\n\t\t\t\t\t\t\tif(res.type == 'ssrc' && res.stat('audioOutputLevel')) {\n\t\t\t\t\t\t\t\tconfig.volume.value = res.stat('audioOutputLevel');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}, 200);\n\t\t\t\treturn 0;\t// We don't have a volume to return yet\n\t\t\t}\n\t\t\treturn config.volume.value;\n\t\t} else {\n\t\t\tJanus.log(\"Getting the remote volume unsupported by browser\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfunction isMuted(handleId, video) {\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\treturn true;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(config.pc === null || config.pc === undefined) {\n\t\t\tJanus.warn(\"Invalid PeerConnection\");\n\t\t\treturn true;\n\t\t}\n\t\tif(config.myStream === undefined || config.myStream === null) {\n\t\t\tJanus.warn(\"Invalid local MediaStream\");\n\t\t\treturn true;\n\t\t}\n\t\tif(video) {\n\t\t\t// Check video track\n\t\t\tif(config.myStream.getVideoTracks() === null\n\t\t\t\t\t|| config.myStream.getVideoTracks() === undefined\n\t\t\t\t\t|| config.myStream.getVideoTracks().length === 0) {\n\t\t\t\tJanus.warn(\"No video track\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !config.myStream.getVideoTracks()[0].enabled;\n\t\t} else {\n\t\t\t// Check audio track\n\t\t\tif(config.myStream.getAudioTracks() === null\n\t\t\t\t\t|| config.myStream.getAudioTracks() === undefined\n\t\t\t\t\t|| config.myStream.getAudioTracks().length === 0) {\n\t\t\t\tJanus.warn(\"No audio track\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !config.myStream.getAudioTracks()[0].enabled;\n\t\t}\n\t}\n\n\tfunction mute(handleId, video, mute) {\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\treturn false;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(config.pc === null || config.pc === undefined) {\n\t\t\tJanus.warn(\"Invalid PeerConnection\");\n\t\t\treturn false;\n\t\t}\n\t\tif(config.myStream === undefined || config.myStream === null) {\n\t\t\tJanus.warn(\"Invalid local MediaStream\");\n\t\t\treturn false;\n\t\t}\n\t\tif(video) {\n\t\t\t// Mute/unmute video track\n\t\t\tif(config.myStream.getVideoTracks() === null\n\t\t\t\t\t|| config.myStream.getVideoTracks() === undefined\n\t\t\t\t\t|| config.myStream.getVideoTracks().length === 0) {\n\t\t\t\tJanus.warn(\"No video track\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconfig.myStream.getVideoTracks()[0].enabled = mute ? false : true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Mute/unmute audio track\n\t\t\tif(config.myStream.getAudioTracks() === null\n\t\t\t\t\t|| config.myStream.getAudioTracks() === undefined\n\t\t\t\t\t|| config.myStream.getAudioTracks().length === 0) {\n\t\t\t\tJanus.warn(\"No audio track\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconfig.myStream.getAudioTracks()[0].enabled = mute ? false : true;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfunction getBitrate(handleId) {\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined ||\n\t\t\t\tpluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n\t\t\tJanus.warn(\"Invalid handle\");\n\t\t\treturn \"Invalid handle\";\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(config.pc === null || config.pc === undefined)\n\t\t\treturn \"Invalid PeerConnection\";\n\t\t// Start getting the bitrate, if getStats is supported\n\t\tif(config.pc.getStats && adapter.browserDetails.browser == \"chrome\") {\n\t\t\t// Do it the Chrome way\n\t\t\tif(config.remoteStream === null || config.remoteStream === undefined) {\n\t\t\t\tJanus.warn(\"Remote stream unavailable\");\n\t\t\t\treturn \"Remote stream unavailable\";\n\t\t\t}\n\t\t\t// http://webrtc.googlecode.com/svn/trunk/samples/js/demos/html/constraints-and-stats.html\n\t\t\tif(config.bitrate.timer === null || config.bitrate.timer === undefined) {\n\t\t\t\tJanus.log(\"Starting bitrate timer (Chrome)\");\n\t\t\t\tconfig.bitrate.timer = setInterval(function() {\n\t\t\t\t\tconfig.pc.getStats(function(stats) {\n\t\t\t\t\t\tvar results = stats.result();\n\t\t\t\t\t\tfor(var i=0; i<results.length; i++) {\n\t\t\t\t\t\t\tvar res = results[i];\n\t\t\t\t\t\t\tif(res.type == 'ssrc' && res.stat('googFrameHeightReceived')) {\n\t\t\t\t\t\t\t\tconfig.bitrate.bsnow = res.stat('bytesReceived');\n\t\t\t\t\t\t\t\tconfig.bitrate.tsnow = res.timestamp;\n\t\t\t\t\t\t\t\tif(config.bitrate.bsbefore === null || config.bitrate.tsbefore === null) {\n\t\t\t\t\t\t\t\t\t// Skip this round\n\t\t\t\t\t\t\t\t\tconfig.bitrate.bsbefore = config.bitrate.bsnow;\n\t\t\t\t\t\t\t\t\tconfig.bitrate.tsbefore = config.bitrate.tsnow;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Calculate bitrate\n\t\t\t\t\t\t\t\t\tvar bitRate = Math.round((config.bitrate.bsnow - config.bitrate.bsbefore) * 8 / (config.bitrate.tsnow - config.bitrate.tsbefore));\n\t\t\t\t\t\t\t\t\tconfig.bitrate.value = bitRate + ' kbits/sec';\n\t\t\t\t\t\t\t\t\t//~ Janus.log(\"Estimated bitrate is \" + config.bitrate.value);\n\t\t\t\t\t\t\t\t\tconfig.bitrate.bsbefore = config.bitrate.bsnow;\n\t\t\t\t\t\t\t\t\tconfig.bitrate.tsbefore = config.bitrate.tsnow;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t\treturn \"0 kbits/sec\";\t// We don't have a bitrate value yet\n\t\t\t}\n\t\t\treturn config.bitrate.value;\n\t\t} else if(config.pc.getStats && adapter.browserDetails.browser == \"firefox\") {\n\t\t\t// Do it the Firefox way\n\t\t\tif(config.remoteStream === null || config.remoteStream === undefined\n\t\t\t\t\t|| config.remoteStream.streams[0] === null || config.remoteStream.streams[0] === undefined) {\n\t\t\t\tJanus.warn(\"Remote stream unavailable\");\n\t\t\t\treturn \"Remote stream unavailable\";\n\t\t\t}\n\t\t\tvar videoTracks = config.remoteStream.streams[0].getVideoTracks();\n\t\t\tif(videoTracks === null || videoTracks === undefined || videoTracks.length < 1) {\n\t\t\t\tJanus.warn(\"No video track\");\n\t\t\t\treturn \"No video track\";\n\t\t\t}\n\t\t\t// https://github.com/muaz-khan/getStats/blob/master/getStats.js\n\t\t\tif(config.bitrate.timer === null || config.bitrate.timer === undefined) {\n\t\t\t\tJanus.log(\"Starting bitrate timer (Firefox)\");\n\t\t\t\tconfig.bitrate.timer = setInterval(function() {\n\t\t\t\t\t// We need a helper callback\n\t\t\t\t\tvar cb = function(res) {\n\t\t\t\t\t\tif(res === null || res === undefined ||\n\t\t\t\t\t\t\t\tres.inbound_rtp_video_1 == null || res.inbound_rtp_video_1 == null) {\n\t\t\t\t\t\t\tconfig.bitrate.value = \"Missing inbound_rtp_video_1\";\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconfig.bitrate.bsnow = res.inbound_rtp_video_1.bytesReceived;\n\t\t\t\t\t\tconfig.bitrate.tsnow = res.inbound_rtp_video_1.timestamp;\n\t\t\t\t\t\tif(config.bitrate.bsbefore === null || config.bitrate.tsbefore === null) {\n\t\t\t\t\t\t\t// Skip this round\n\t\t\t\t\t\t\tconfig.bitrate.bsbefore = config.bitrate.bsnow;\n\t\t\t\t\t\t\tconfig.bitrate.tsbefore = config.bitrate.tsnow;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Calculate bitrate\n\t\t\t\t\t\t\tvar bitRate = Math.round((config.bitrate.bsnow - config.bitrate.bsbefore) * 8 / (config.bitrate.tsnow - config.bitrate.tsbefore));\n\t\t\t\t\t\t\tconfig.bitrate.value = bitRate + ' kbits/sec';\n\t\t\t\t\t\t\tconfig.bitrate.bsbefore = config.bitrate.bsnow;\n\t\t\t\t\t\t\tconfig.bitrate.tsbefore = config.bitrate.tsnow;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t// Actually get the stats\n\t\t\t\t\tconfig.pc.getStats(videoTracks[0], function(stats) {\n\t\t\t\t\t\tcb(stats);\n\t\t\t\t\t}, cb);\n\t\t\t\t}, 1000);\n\t\t\t\treturn \"0 kbits/sec\";\t// We don't have a bitrate value yet\n\t\t\t}\n\t\t\treturn config.bitrate.value;\n\t\t} else {\n\t\t\tJanus.warn(\"Getting the video bitrate unsupported by browser\");\n\t\t\treturn \"Feature unsupported by browser\";\n\t\t}\n\t}\n\n\tfunction webrtcError(error) {\n\t\tJanus.error(\"WebRTC error:\", error);\n\t}\n\n\tfunction cleanupWebrtc(handleId, hangupRequest) {\n\t\tJanus.log(\"Cleaning WebRTC stuff\");\n\t\tvar pluginHandle = pluginHandles[handleId];\n\t\tif(pluginHandle === null || pluginHandle === undefined) {\n\t\t\t// Nothing to clean\n\t\t\treturn;\n\t\t}\n\t\tvar config = pluginHandle.webrtcStuff;\n\t\tif(config !== null && config !== undefined) {\n\t\t\tif(hangupRequest === true) {\n\t\t\t\t// Send a hangup request (we don't really care about the response)\n\t\t\t\tvar request = { \"janus\": \"hangup\", \"transaction\": Janus.randomString(12) };\n\t\t\t\tif(token !== null && token !== undefined)\n\t\t\t\t\trequest[\"token\"] = token;\n\t\t\t\tif(apisecret !== null && apisecret !== undefined)\n\t\t\t\t\trequest[\"apisecret\"] = apisecret;\n\t\t\t\tJanus.debug(\"Sending hangup request (handle=\" + handleId + \"):\");\n\t\t\t\tJanus.debug(request);\n\t\t\t\tif(websockets) {\n\t\t\t\t\trequest[\"session_id\"] = sessionId;\n\t\t\t\t\trequest[\"handle_id\"] = handleId;\n\t\t\t\t\tws.send(JSON.stringify(request));\n\t\t\t\t} else {\n\t\t\t\t\tJanus.ajax({\n\t\t\t\t\t\ttype: 'POST',\n\t\t\t\t\t\turl: server + \"/\" + sessionId + \"/\" + handleId,\n\t\t\t\t\t\twithCredentials: withCredentials,\n\t\t\t\t\t\tcache: false,\n\t\t\t\t\t\tcontentType: \"application/json\",\n\t\t\t\t\t\tdata: JSON.stringify(request),\n\t\t\t\t\t\tdataType: \"json\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cleanup stack\n\t\t\tconfig.remoteStream = null;\n\t\t\tif(config.volume.timer)\n\t\t\t\tclearInterval(config.volume.timer);\n\t\t\tconfig.volume.value = null;\n\t\t\tif(config.bitrate.timer)\n\t\t\t\tclearInterval(config.bitrate.timer);\n\t\t\tconfig.bitrate.timer = null;\n\t\t\tconfig.bitrate.bsnow = null;\n\t\t\tconfig.bitrate.bsbefore = null;\n\t\t\tconfig.bitrate.tsnow = null;\n\t\t\tconfig.bitrate.tsbefore = null;\n\t\t\tconfig.bitrate.value = null;\n\t\t\ttry {\n\t\t\t\t// Try a MediaStream.stop() first\n\t\t\t\tif(!config.streamExternal && config.myStream !== null && config.myStream !== undefined) {\n\t\t\t\t\tJanus.log(\"Stopping local stream\");\n\t\t\t\t\tconfig.myStream.stop();\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\t// Do nothing if this fails\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// Try a MediaStreamTrack.stop() for each track as well\n\t\t\t\tif(!config.streamExternal && config.myStream !== null && config.myStream !== undefined) {\n\t\t\t\t\tJanus.log(\"Stopping local stream tracks\");\n\t\t\t\t\tvar tracks = config.myStream.getTracks();\n\t\t\t\t\tfor(var i in tracks) {\n\t\t\t\t\t\tvar mst = tracks[i];\n\t\t\t\t\t\tJanus.log(mst);\n\t\t\t\t\t\tif(mst !== null && mst !== undefined)\n\t\t\t\t\t\t\tmst.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\t// Do nothing if this fails\n\t\t\t}\n\t\t\tconfig.streamExternal = false;\n\t\t\tconfig.myStream = null;\n\t\t\t// Close PeerConnection\n\t\t\ttry {\n\t\t\t\tconfig.pc.close();\n\t\t\t} catch(e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tconfig.pc = null;\n\t\t\tconfig.mySdp = null;\n\t\t\tconfig.iceDone = false;\n\t\t\tconfig.sdpSent = false;\n\t\t\tconfig.dataChannel = null;\n\t\t\tconfig.dtmfSender = null;\n\t\t}\n\t\tpluginHandle.oncleanup();\n\t}\n\n\t// Helper methods to parse a media object\n\tfunction isAudioSendEnabled(media) {\n\t\tJanus.debug(\"isAudioSendEnabled:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn true;\t// Default\n\t\tif(media.audio === false)\n\t\t\treturn false;\t// Generic audio has precedence\n\t\tif(media.audioSend === undefined || media.audioSend === null)\n\t\t\treturn true;\t// Default\n\t\treturn (media.audioSend === true);\n\t}\n\n\tfunction isAudioSendRequired(media) {\n\t\tJanus.debug(\"isAudioSendRequired:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn false;\t// Default\n\t\tif(media.audio === false || media.audioSend === false)\n\t\t\treturn false;\t// If we're not asking to capture audio, it's not required\n\t\tif(media.failIfNoAudio === undefined || media.failIfNoAudio === null)\n\t\t\treturn false;\t// Default\n\t\treturn (media.failIfNoAudio === true);\n\t}\n\n\tfunction isAudioRecvEnabled(media) {\n\t\tJanus.debug(\"isAudioRecvEnabled:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn true;\t// Default\n\t\tif(media.audio === false)\n\t\t\treturn false;\t// Generic audio has precedence\n\t\tif(media.audioRecv === undefined || media.audioRecv === null)\n\t\t\treturn true;\t// Default\n\t\treturn (media.audioRecv === true);\n\t}\n\n\tfunction isVideoSendEnabled(media) {\n\t\tJanus.debug(\"isVideoSendEnabled:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn true;\t// Default\n\t\tif(media.video === false)\n\t\t\treturn false;\t// Generic video has precedence\n\t\tif(media.videoSend === undefined || media.videoSend === null)\n\t\t\treturn true;\t// Default\n\t\treturn (media.videoSend === true);\n\t}\n\n\tfunction isVideoSendRequired(media) {\n\t\tJanus.debug(\"isVideoSendRequired:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn false;\t// Default\n\t\tif(media.video === false || media.videoSend === false)\n\t\t\treturn false;\t// If we're not asking to capture video, it's not required\n\t\tif(media.failIfNoVideo === undefined || media.failIfNoVideo === null)\n\t\t\treturn false;\t// Default\n\t\treturn (media.failIfNoVideo === true);\n\t}\n\n\tfunction isVideoRecvEnabled(media) {\n\t\tJanus.debug(\"isVideoRecvEnabled:\", media);\n\t\tif(media === undefined || media === null)\n\t\t\treturn true;\t// Default\n\t\tif(media.video === false)\n\t\t\treturn false;\t// Generic video has precedence\n\t\tif(media.videoRecv === undefined || media.videoRecv === null)\n\t\t\treturn true;\t// Default\n\t\treturn (media.videoRecv === true);\n\t}\n\n\tfunction isDataEnabled(media) {\n\t\tJanus.debug(\"isDataEnabled:\", media);\n\t\tif(adapter.browserDetails.browser == \"edge\") {\n\t\t\tJanus.warn(\"Edge doesn't support data channels yet\");\n\t\t\treturn false;\n\t\t}\n\t\tif(media === undefined || media === null)\n\t\t\treturn false;\t// Default\n\t\treturn (media.data === true);\n\t}\n\n\tfunction isTrickleEnabled(trickle) {\n\t\tJanus.debug(\"isTrickleEnabled:\", trickle);\n\t\tif(trickle === undefined || trickle === null)\n\t\t\treturn true;\t// Default is true\n\t\treturn (trickle === true);\n\t}\n};\n\n\nexport default Janus;",{"ruleId":"160","replacedBy":"161"},{"ruleId":"162","replacedBy":"163"},{"ruleId":"164","severity":1,"message":"165","line":39,"column":7,"nodeType":"166","endLine":39,"endColumn":9,"suggestions":"167"},{"ruleId":"164","severity":1,"message":"165","line":40,"column":7,"nodeType":"166","endLine":40,"endColumn":9,"suggestions":"168"},{"ruleId":"169","severity":1,"message":"170","line":7,"column":8,"nodeType":"171","messageId":"172","endLine":7,"endColumn":16},{"ruleId":"164","severity":1,"message":"173","line":52,"column":7,"nodeType":"166","endLine":52,"endColumn":9,"suggestions":"174"},{"ruleId":"164","severity":1,"message":"175","line":35,"column":7,"nodeType":"166","endLine":35,"endColumn":9,"suggestions":"176"},{"ruleId":"177","severity":1,"message":"178","line":47,"column":25,"nodeType":"179","endLine":47,"endColumn":65},{"ruleId":"177","severity":1,"message":"178","line":61,"column":37,"nodeType":"179","endLine":61,"endColumn":94},{"ruleId":"177","severity":1,"message":"178","line":64,"column":37,"nodeType":"179","endLine":64,"endColumn":94},{"ruleId":"177","severity":1,"message":"178","line":67,"column":37,"nodeType":"179","endLine":67,"endColumn":123},{"ruleId":"177","severity":1,"message":"178","line":22,"column":25,"nodeType":"179","endLine":22,"endColumn":67},{"ruleId":"169","severity":1,"message":"180","line":2,"column":10,"nodeType":"171","messageId":"172","endLine":2,"endColumn":29},{"ruleId":"169","severity":1,"message":"181","line":15,"column":5,"nodeType":"171","messageId":"172","endLine":15,"endColumn":15},{"ruleId":"169","severity":1,"message":"182","line":154,"column":24,"nodeType":"171","messageId":"172","endLine":154,"endColumn":40},{"ruleId":"164","severity":1,"message":"183","line":231,"column":29,"nodeType":"184","endLine":231,"endColumn":33},{"ruleId":"169","severity":1,"message":"181","line":14,"column":5,"nodeType":"171","messageId":"172","endLine":14,"endColumn":15},{"ruleId":"164","severity":1,"message":"183","line":176,"column":29,"nodeType":"184","endLine":176,"endColumn":33},{"ruleId":"169","severity":1,"message":"185","line":19,"column":21,"nodeType":"171","messageId":"172","endLine":19,"endColumn":33},{"ruleId":"169","severity":1,"message":"186","line":21,"column":17,"nodeType":"171","messageId":"172","endLine":21,"endColumn":25},{"ruleId":"169","severity":1,"message":"187","line":22,"column":15,"nodeType":"171","messageId":"172","endLine":22,"endColumn":23},{"ruleId":"164","severity":1,"message":"188","line":99,"column":6,"nodeType":"166","endLine":99,"endColumn":8,"suggestions":"189"},{"ruleId":"164","severity":1,"message":"190","line":108,"column":4,"nodeType":"166","endLine":108,"endColumn":19,"suggestions":"191"},{"ruleId":"169","severity":1,"message":"192","line":148,"column":7,"nodeType":"171","messageId":"172","endLine":148,"endColumn":13},{"ruleId":"169","severity":1,"message":"193","line":14,"column":8,"nodeType":"171","messageId":"172","endLine":14,"endColumn":24},{"ruleId":"169","severity":1,"message":"194","line":15,"column":8,"nodeType":"171","messageId":"172","endLine":15,"endColumn":22},{"ruleId":"164","severity":1,"message":"188","line":103,"column":5,"nodeType":"166","endLine":103,"endColumn":7,"suggestions":"195"},{"ruleId":"164","severity":1,"message":"196","line":134,"column":4,"nodeType":"166","endLine":134,"endColumn":19,"suggestions":"197"},{"ruleId":"164","severity":1,"message":"198","line":142,"column":4,"nodeType":"166","endLine":142,"endColumn":19,"suggestions":"199"},{"ruleId":"200","severity":1,"message":"201","line":492,"column":25,"nodeType":"202","messageId":"203","endLine":492,"endColumn":26},{"ruleId":"164","severity":1,"message":"204","line":48,"column":7,"nodeType":"166","endLine":48,"endColumn":9,"suggestions":"205"},{"ruleId":"160","severity":1,"message":"206","line":60,"column":4,"nodeType":"171","messageId":"207","endLine":60,"endColumn":11},{"ruleId":"208","severity":1,"message":"209","line":194,"column":24,"nodeType":"202","messageId":"210","endLine":194,"endColumn":26},{"ruleId":"211","severity":1,"message":"212","line":422,"column":8,"nodeType":"171","messageId":"213","endLine":422,"endColumn":19},{"ruleId":"211","severity":1,"message":"214","line":424,"column":9,"nodeType":"171","messageId":"213","endLine":424,"endColumn":22},{"ruleId":"211","severity":1,"message":"215","line":451,"column":8,"nodeType":"171","messageId":"213","endLine":451,"endColumn":14},{"ruleId":"211","severity":1,"message":"216","line":456,"column":8,"nodeType":"171","messageId":"213","endLine":456,"endColumn":20},{"ruleId":"211","severity":1,"message":"215","line":467,"column":8,"nodeType":"171","messageId":"213","endLine":467,"endColumn":14},{"ruleId":"211","severity":1,"message":"216","line":472,"column":8,"nodeType":"171","messageId":"213","endLine":472,"endColumn":20},{"ruleId":"211","severity":1,"message":"215","line":484,"column":8,"nodeType":"171","messageId":"213","endLine":484,"endColumn":14},{"ruleId":"211","severity":1,"message":"216","line":489,"column":8,"nodeType":"171","messageId":"213","endLine":489,"endColumn":20},{"ruleId":"211","severity":1,"message":"215","line":499,"column":8,"nodeType":"171","messageId":"213","endLine":499,"endColumn":14},{"ruleId":"211","severity":1,"message":"216","line":504,"column":8,"nodeType":"171","messageId":"213","endLine":504,"endColumn":20},{"ruleId":"211","severity":1,"message":"212","line":514,"column":8,"nodeType":"171","messageId":"213","endLine":514,"endColumn":19},{"ruleId":"211","severity":1,"message":"214","line":516,"column":9,"nodeType":"171","messageId":"213","endLine":516,"endColumn":22},{"ruleId":"211","severity":1,"message":"215","line":526,"column":8,"nodeType":"171","messageId":"213","endLine":526,"endColumn":14},{"ruleId":"211","severity":1,"message":"216","line":539,"column":8,"nodeType":"171","messageId":"213","endLine":539,"endColumn":20},{"ruleId":"208","severity":1,"message":"217","line":603,"column":24,"nodeType":"202","messageId":"210","endLine":603,"endColumn":26},{"ruleId":"208","severity":1,"message":"217","line":686,"column":22,"nodeType":"202","messageId":"210","endLine":686,"endColumn":24},{"ruleId":"208","severity":1,"message":"217","line":748,"column":24,"nodeType":"202","messageId":"210","endLine":748,"endColumn":26},{"ruleId":"208","severity":1,"message":"217","line":748,"column":66,"nodeType":"202","messageId":"210","endLine":748,"endColumn":68},{"ruleId":"208","severity":1,"message":"217","line":833,"column":37,"nodeType":"202","messageId":"210","endLine":833,"endColumn":39},{"ruleId":"208","severity":1,"message":"217","line":833,"column":83,"nodeType":"202","messageId":"210","endLine":833,"endColumn":85},{"ruleId":"208","severity":1,"message":"209","line":1452,"column":38,"nodeType":"202","messageId":"210","endLine":1452,"endColumn":40},{"ruleId":"208","severity":1,"message":"209","line":1458,"column":38,"nodeType":"202","messageId":"210","endLine":1458,"endColumn":40},{"ruleId":"208","severity":1,"message":"209","line":1459,"column":35,"nodeType":"202","messageId":"210","endLine":1459,"endColumn":37},{"ruleId":"208","severity":1,"message":"209","line":1459,"column":62,"nodeType":"202","messageId":"210","endLine":1459,"endColumn":64},{"ruleId":"211","severity":1,"message":"218","line":1505,"column":11,"nodeType":"171","messageId":"213","endLine":1505,"endColumn":21},{"ruleId":"208","severity":1,"message":"217","line":1627,"column":33,"nodeType":"202","messageId":"210","endLine":1627,"endColumn":35},{"ruleId":"208","severity":1,"message":"209","line":1648,"column":23,"nodeType":"202","messageId":"210","endLine":1648,"endColumn":25},{"ruleId":"208","severity":1,"message":"217","line":1650,"column":26,"nodeType":"202","messageId":"210","endLine":1650,"endColumn":28},{"ruleId":"208","severity":1,"message":"217","line":1681,"column":34,"nodeType":"202","messageId":"210","endLine":1681,"endColumn":36},{"ruleId":"208","severity":1,"message":"217","line":1791,"column":37,"nodeType":"202","messageId":"210","endLine":1791,"endColumn":39},{"ruleId":"208","severity":1,"message":"217","line":1791,"column":84,"nodeType":"202","messageId":"210","endLine":1791,"endColumn":86},{"ruleId":"208","severity":1,"message":"217","line":1849,"column":37,"nodeType":"202","messageId":"210","endLine":1849,"endColumn":39},{"ruleId":"208","severity":1,"message":"217","line":1849,"column":84,"nodeType":"202","messageId":"210","endLine":1849,"endColumn":86},{"ruleId":"208","severity":1,"message":"217","line":1931,"column":59,"nodeType":"202","messageId":"210","endLine":1931,"endColumn":61},{"ruleId":"208","severity":1,"message":"217","line":1944,"column":20,"nodeType":"202","messageId":"210","endLine":1944,"endColumn":22},{"ruleId":"208","severity":1,"message":"217","line":2046,"column":59,"nodeType":"202","messageId":"210","endLine":2046,"endColumn":61},{"ruleId":"208","severity":1,"message":"217","line":2060,"column":20,"nodeType":"202","messageId":"210","endLine":2060,"endColumn":22},{"ruleId":"208","severity":1,"message":"217","line":2082,"column":66,"nodeType":"202","messageId":"210","endLine":2082,"endColumn":68},{"ruleId":"208","severity":1,"message":"217","line":2295,"column":37,"nodeType":"202","messageId":"210","endLine":2295,"endColumn":39},"no-native-reassign",["219"],"no-negated-in-lhs",["220"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'userId'. Either include it or remove the dependency array.","ArrayExpression",["221"],["222"],"no-unused-vars","'firebase' is defined but never used.","Identifier","unusedVar","React Hook useEffect has missing dependencies: 'props.lessons', 'props.role', and 'props.sessionId'. Either include them or remove the dependency array.",["223"],"React Hook useEffect has a missing dependency: 'props.StudentId'. Either include it or remove the dependency array.",["224"],"jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/anchor-is-valid.md","JSXOpeningElement","'SystemUpdateTwoTone' is defined but never used.","'drawVisual' is assigned a value but never used.","'setSessionStatus' is assigned a value but never used.","Assignments to the 'webrtcUp' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","Literal","'setIsDrawing' is assigned a value but never used.","'setEmogi' is assigned a value but never used.","'setColor' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'onDrawingEvent', 'onTextEvent', and 'props.sessionId'. Either include them or remove the dependency array.",["225"],"React Hook useEffect has missing dependencies: 'current' and 'toolName'. Either include them or remove the dependency array.",["226"],"'typing' is assigned a value but never used.","'TextareaAutosize' is defined but never used.","'AutowidthInput' is defined but never used.",["227"],"React Hook useEffect has missing dependencies: 'annotations' and 'props.lessonTitles'. Either include them or remove the dependency array. Mutable values like 'count.current' aren't valid dependencies because mutating them doesn't re-render the component.",["228"],"React Hook useEffect has a missing dependency: 'toolName'. Either include it or remove the dependency array.",["229"],"no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","React Hook useEffect has a missing dependency: 'props.sessionId'. Either include it or remove the dependency array.",["230"],"Read-only global 'console' should not be modified.","nativeReassign","eqeqeq","Expected '!==' and instead saw '!='.","unexpected","no-redeclare","'transaction' is already defined.","redeclared","'reportSuccess' is already defined.","'sender' is already defined.","'pluginHandle' is already defined.","Expected '===' and instead saw '=='.","'firefoxVer' is already defined.","no-global-assign","no-unsafe-negation",{"desc":"231","fix":"232"},{"desc":"231","fix":"233"},{"desc":"234","fix":"235"},{"desc":"236","fix":"237"},{"desc":"238","fix":"239"},{"desc":"240","fix":"241"},{"desc":"238","fix":"242"},{"desc":"243","fix":"244"},{"desc":"245","fix":"246"},{"desc":"247","fix":"248"},"Update the dependencies array to be: [userId]",{"range":"249","text":"250"},{"range":"251","text":"250"},"Update the dependencies array to be: [props.lessons, props.role, props.sessionId]",{"range":"252","text":"253"},"Update the dependencies array to be: [props.StudentId]",{"range":"254","text":"255"},"Update the dependencies array to be: [onDrawingEvent, onTextEvent, props.sessionId]",{"range":"256","text":"257"},"Update the dependencies array to be: [current, keyStartPoint, toolName]",{"range":"258","text":"259"},{"range":"260","text":"257"},"Update the dependencies array to be: [annotations, props.lessonTitles]",{"range":"261","text":"262"},"Update the dependencies array to be: [keyStartPoint, toolName]",{"range":"263","text":"264"},"Update the dependencies array to be: [props.sessionId]",{"range":"265","text":"266"},[1327,1329],"[userId]",[1302,1304],[2153,2155],"[props.lessons, props.role, props.sessionId]",[1134,1136],"[props.StudentId]",[3243,3245],"[onDrawingEvent, onTextEvent, props.sessionId]",[3375,3390],"[current, keyStartPoint, toolName]",[3407,3409],[4555,4570],"[annotations, props.lessonTitles]",[4712,4727],"[keyStartPoint, toolName]",[1911,1913],"[props.sessionId]"]